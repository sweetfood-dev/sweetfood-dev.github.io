var store = [{
        "title": "[백준 11726] 2 * n 타일링",
        "excerpt":"링크   문제   2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.   아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.   입력     첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)    출력     첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.    코드  func solve(n : Int) { \tguard n &gt; 2 else { return n } \tvar arr = [Int](repeating: 0, count: n + 1) \tarr[1] = 1 \tarr[2] = 2 \tfor i in 3 ... n { \t\tarr[i] = arr[i - 1] + arr[i - 2] \t\tarr[i] %= 10007 \t} \t \treturn arr[i] }   풀이 : 조금 더 이해가 되면 작성할 예정  ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/11726-2-n/",
        "teaser": null
      },{
        "title": "동적계획법(DP) 이론",
        "excerpt":"동적계획법이란?      최적화 문제를 연구하는 수학이론에서 왔다.   처음 주어진 문제를 더 작은 문제로 나눈 뒤 조각의 답을 계산하고 이러한 답들로 원래 문제에 대한 답을 계산, 도출   어떤 부분문제는 두개 이상의 문제를 푸는데 사용할 수 있어 한번만 계산하고 계산 결과를 재활용하여 속도의 향상을 얻는다   계산한 값을 저장하는 곳을 캐시라고 한다.   이러한 한번만 계산한 값을 재활용 하는 최적화 기법을 메모이제이션 이라고 한다.  ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/Algorithm-DP-%EC%9D%B4%EB%A1%A0/",
        "teaser": null
      },{
        "title": "[백준 11727] 2 * n 타일링2",
        "excerpt":"문제  링크   2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.   입력     첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)    출력     첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.    풀이  앞에 타일링 문제에서 2 * 2 타일이 추가되었을 뿐 개념은 같다 (n - 1)  + (n - 2) * 2 &gt; 2 * 2 타일은 결국 ( n - 2 ) 타일과 같다   func solve(n : Int) -&gt; Int {     if n == 0 { return 0}     if n == 1 { return 1}     if n == 2 { return 3}     var arr = [Int](repeating: 0, count : n + 1)      arr[1] = 1     arr[2] = 3     for i in 3 ... n {         arr[i] = arr[i - 1] + (arr[i - 2] * 2)         arr[i] %= 10007     }     return arr[n] }  ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ11727-DP/",
        "teaser": null
      },{
        "title": "[백준 1463] 1로 만들기",
        "excerpt":"링크   문제   정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.     X가 3으로 나누어 떨어지면, 3으로 나눈다.   X가 2로 나누어 떨어지면, 2로 나눈다.   1을 뺀다.            정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.            입력     첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.    출력     첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.    구현 :  메모이제이션을 사용한 재귀로 구현.   var cache = [Int](repeating: 0, count: 1000001)  func solve(x: Int) -&gt; Int { \tguard x &gt;= 1 else { return 0 } \tif x == 1 { return 1 } \tif cache[x] &gt; 0 { \t\treturn cache[x] \t} \tvar minVal = Int.max \tminVal = min(solve(x: x - 1), minVal) \tif x % 3 == 0 { minVal = min(solve(x: x / 3), minVal) }  \tif x % 2 == 0 { minVal = min(solve(x: x / 2), minVal) } \tcache[x] = minVal + 1 \treturn minVal + 1 \t}  if let x = Int(readLine()!) { \tprint(solve(x: x) - 1) }   x가 10000 이하일때는 잘 동작했지만 그 이상이 되면 재귀의 깊이가 깊어져 런타임 에러 발생.   고민고민을 해봤지만 고민만 1시간이 넘어가 결국 구글링…   재귀가 아닌 상향식 DP를 사용하여 접근하는 방법이 많았다   일련의 규칙이 있는데   x == 1 ,  0  , 연산 필요 없음 x == 2 , ( 2 / 2 ) = 1, 1번 연산 x == 3,  ( 3 / 3 ) = 1, 1번 연산 x == 4,  ( 4 / 2 ) = 2, (2 / 2) = 1, 총 2번 연산 x == 5 , ( 5 - 1 ) =  4 , ( 4 / 2 ) = 2, ( 2 / 2 ) = 1, 총 3번 연산   x 가 4 이상 일 때는 이 전의 결과를 포함하고 있다 .   이를 코드로 나타내면    func solve(x: Int) -&gt; Int {     if x == 1 { return 0 }     else if x == 2 { return 1 }     else if x == 3 { return 1 }     else{         var cache = [Int](repeating: 0, count: x + 1)         cache[1] = 0         cache[2] = 1         cache[3] = 1                  for i in 4 ... x {             cache[i] = cache[i - 1] + 1             if i % 3 == 0 {                 cache[i] = min(cache[i / 3] + 1, cache[i])             }             if i % 2 == 0 {                 cache[i] = min(cache[i / 2] + 1, cache[i])             }         }         return cache[x]     } } if let x = Int(readLine()!) {     print(solve(x: x)) }  ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ1463-DP/",
        "teaser": null
      },{
        "title": "[백준 9095] 1, 2, 3 더하기",
        "excerpt":"문제  링크   정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.      1+1+1+1   1+1+2   1+2+1   2+1+1   2+2   1+3   3+1   정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.   입력     첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.    출력     각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.    풀이 :  1~3의 합으로 정수 N을 나타내는 경우의 수만 구하면된다,  구성은 상관없다는 소리.   N == 1 일 때 경우의 수 :   1  N == 2 일 때 경우의 수 :   1 + 1  2  N == 3 일 때 경우의 수 :   1 + 1 + 1  1 + 2  2 + 1  3   일 때,     N == 4는 다음과 같다   N == 4 :    1 + 1 + 1 + 1 :     3의 경우의 수 + 1    1 + 1 + 2 :             2의 경우의 수 + 2   1 + 2+ 1 :             3의 경우의 수 + 1   2 + 1 + 1 :             3의 경우의 수 + 1   2 + 2 :                     2의 경우의 수 + 2   1 + 3 :                     1의 경우의 수 + 3   3 + 1 :                     3의 경우의 수 + 1    1의 경우의 수 + 2의 경우의 수 + 3의 경우의 수 의 합과 같다.  수식으로 표현하면 N = (N - 3) + (N - 2) + (N - 1) 이므로 이를 그대로 사용!    func solve(n : Int) -&gt; Int{     if n == 0 { return 0 }     else if n == 3 { return 4 }     else if n == 2 { return 2 }     else if n == 1 { return 1 }     var arr = [Int](repeating:0, count: n + 1)     arr[1] = 1     arr[2] = 2     arr[3] = 4     for i in 4 ... n {         arr[i] = arr[i - 3] + arr[i - 2] + arr[i - 1]     }     return arr[n] }  var map = [Int:Int]() map[0] = 0 map[1] = 1 map[2] = 2 map[3] = 4 func recursive(n : Int) -&gt; Int {     if let res = map[n] {         return res     }          map[n] = recursive(n: n - 3) + recursive(n: n - 2) + recursive(n: n - 1)     return map[n]! } if let count = Int(readLine()!){          for _ in 0 ..&lt; count {         let n = Int(readLine()!)!         // 상향식         /*print(solve(n: n))*/         // 하향식         print(recursive(n: n))     } }   상향식과 하향식 모두 가능!  ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ9095-DP/",
        "teaser": null
      },{
        "title": "[백준 10844] 쉬운 계단 수",
        "excerpt":"문제  링크   45656이란 수를 보자.   이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.   세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.   N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)   입력     첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.    출력     첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.    풀이   N == 1 일 때, 계단 수 : 1,2,3,4,5,6,7,8,9  N == 2 일 때, 계단 수 : 10,12, 21, 23, 32, 34, 43, 45, 54, 56, 65, 67, 76, 78, 87, 89, 98    규칙을 찾아 보자  N == 1 일 때, 계단 수 에서 N == 2일 때, 계단 수를 구할 수 있을까?  N == 2 일 때, 계단수 10, 12를 봐보자   N == 2 일 때, 10과 12는 N == 1 일 때, 1에서 0 과 2를 1의 자리에 넣어 준 것과 같다  N == 2 일 때, 21과 23은 N == 1 일 때, 2에서 1과 3을 1의 자리에 넣어 준 것과 같다.  N == 2 일 때의 계단 수는 N == 1일 때 계단 수에서 1의 자리에서 +1과, -1을 해준 숫자들이 들어감을 확인할 수 있다  N == 2 일 때, 10과 12는 N == 1 일 때, 1에  1 - 1, 즉 0을 붙여 10, 1 에 1 + 1, 즉 2를 붙여 12가 만들어 짐을 알 수 있다.  이를 이용하면 N이 주어질 때 마지막 1의 자리가 K인 숫자의 계단 수의 갯수는  N - 1 번째의 K - 1의 계단 수의 갯수 + N - 1번째의 K + 1의 계단수의 갯수일 것이다  예를 들어 N == 2 일 때 1의 자리 숫자가 3으로 끝나는 계단 수의 갯수는   N == 1 일 때, 2의 갯수,  그리고 4의 갯수를 합치면 된다  글 보다 표를 그려 확인 해보자     수식으로 구성 해보자   N : 숫자의 길이, K : N 의 계단 수의 1의 자리   N[K] = N-1[K - 1] + N-1[K+1] 이 때, 주의 할 것이 있다   N[K] == 0 일 경우엔  이전 단계에서 1일 경우만 더해주고 ( 즉, N-1[1])  K == 9 : 8일 경우만 더해 준다 ( 즉 N-1[8])     이를 그대로 코드로 옮겨 보자   func solve(n : Int) {     if n == 1 { // 1일 경우는 무조건 9개 밖에 없다         print(9)         return     }     let mod = 1_000_000_000 // 결과값에서 쓰일 나머지 연산 값      var map = Array(repeating: Array(repeating: 0, count: 10), count: 101)          for i in 1 ... 9 {         map[1][i] = 1     }          for i in 2 ... n {         map[i][0] = map[i-1][1]         map[i][9] = map[i-1][8]         for k in 1 ... 8 {             map[i][k] = (map[i-1][k - 1] + map[i-1][k + 1]) % mod         }     }          let result = map[n].reduce(0,+)          print(result % mod) }  ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ10844-DP/",
        "teaser": null
      },{
        "title": "[백준 11057] 오르막 수",
        "excerpt":"문제  링크   오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.   예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.   수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. 수는 0으로 시작할 수 있다.    입력     첫째 줄에 N (1 ≤ N ≤ 1,000)이 주어진다.    출력     첫째 줄에 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를 출력한다.    풀이   N == 1일 때,  아래와 같다                   Index       0       1       2       3       4       5       6       7       8       9                       오르막 수의 개수       1       1       1       1       1       1       1       1       1       1             N == 2일 때, 숫자의 길이는 2개 즉 ㅁㅁ 으로 구성되어지고  이 때 K == 0인 경우                   뒤의 숫자       0       1       2       3       4       5       6       7       8       9                       결과       00       01       02       03       04       05       06       07       08       09           N == 2 &amp;&amp; K == 0                    Index       0       1       2       3       4       5       6       7       8       9                       오르막 수의 개수       10       ?       ?       ?       ?       ?       ?       ?       ?       ?           K == 1인 경우                   뒤의 숫자       0       1       2       3       4       5       6       7       8       9                       결과       X       11       12       13       14       15       16       17       18       19           N == 2 &amp;&amp; K == 0                    Index       0       1       2       3       4       5       6       7       8       9                       오르막 수의 개수       10       9       ?       ?       ?       ?       ?       ?       ?       ?           보는 것과 같이 k 숫자의 뒤에 k ~ 9 까지가 붙어 오르막수를 만들 수 있다    이를 수식으로 만들면  N[K] = N-1[K] + N-1[K+1] + N-1[K+2] ….. N - 1[9]    이를 이용해 그대로 코드로 구현    func solve(n: Int) {     if n == 1 { // n이 1이면 10개         print(10)         return     }     let mod = 1_000_7 // 정답에 나머지값을 계산해 출력     var map = Array(repeating:Array(repeating:0, count: 10), count: 1001)     for i in 0 ... 9 {         map[1][i] = 1     }     for i in 2 ... n {         for j in 0 ... 9 {             for k in j ... 9 { // j가 0 이면 0 ~ 9 까지, j가 1이면 1 ~ 9 까지                  map[i][j] += map[i-1][k] % mod             }         }     }     print(map[n].reduce(0, +) % mod) }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ11057-DP/",
        "teaser": null
      },{
        "title": "[백준 2193] 이친수",
        "excerpt":"문제  링크   0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.      이친수는 0으로 시작하지 않는다.    이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.  예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.    N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.    입력     첫째 줄에 N이 주어진다.     출력     첫째 줄에 N자리 이친수의 개수를 출력한다.     풀이   N == 1 일 때, 이친수는 1   N == 2 일 때, 이친수는 10   N == 3 일 때, 이친수는 100, 101   N == 4 일 때, 이친수는 1000, 1001, 1010     유심히 보면 규칙이 보인다.   N == 4 에서 1000과 1001은 N == 3의 100을 가지고 만들 수 있다.   N == 4 에서 1010은 N == 3의 101을 가지고 만들 수 있다.     차이점은 뭘까?   문제에서 조건 2에 의해 1이 두번 연속으로 나타나면 안된다  즉 끝자리가 1이면 다음에 나타나는 수는 0밖에 없고  끝 자리가 0이면 다음에 나타나는 수는 0, 1 모두 가능하다     수식을 세워보자!  K == 0 일 때  N[0] = N -1[0] + N - 1[1]   N번째 0으로 끝나는 이친 수의 갯수는 N-1번째 0으로 끝나는 이친수 갯수와 1로 끝나는 이친수 갯수의 합이다  N[1] = N-1[0]  N번째 1로 끝나는 이친 수의 갯수는 N-1번째 1로 끝나는 이친수 갯수와 같다     func solve(n: Int){     if n == 1 {         print(1)         return     }          var map = Array(repeating:Array(repeating:0, count:2), count: n + 1) \t\t//n == 1일 때 이친수는 1 하나뿐     map[1][0] = 0      map[1][1] = 1          for i in 2 ... n {         map[i][0] = map[i-1][0] + map[i-1][1]         map[i][1] = map[i-1][0]     }          print(map[n].reduce(0,+)) }  ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ2193-DP/",
        "teaser": null
      },{
        "title": "[백준 9465] 스티커",
        "excerpt":"문제  링크   이번 포스트 부터 문제와 입력/출력은 따로 작성하지 않겠습니다 상단 링크에서 확인해주세요!    풀이   스티커를 선택하는 방법은 3가지가 있다                   아무것도 선택 안함       위에만 선택       아래만 선택                       x       o       x                 x       x       o           그리고 몇 가지 정의를 한다   W[0][N] : 첫 번째 행의 N 번째 숫자  W[1][N] : 두 번째 행의 N 번째 숫자   D[0][N] : 아무것도 선택 안했을 경우 N 숫자에서의 최대값   D[1][N] : 첫 번째 행을 선택했을 경우 N 숫자에서의 최대값   D[2][N] : 두 번째 행을 선택했을 경우 N 숫자에서의 최대값     경우 1 : N번째 숫자에서 아무것도 선택안할 경우에는 N - 1 번째의 최대값 을 넣는다  D[0][N] = max(D[0][N-1],D[1][N-1],D[2][N-1])   경우 2: N번째 숫자에서 첫 번째 행을 선택했을 경우 N-1번째의 아무것도 선택 안했을 경우최대값과,  N-1번째의 두 번째 행을 선택했을 경우의 최대값중 큰값과 첫번째 행 W[0][N]을 더한다  D[1][N] = max(D[0][N-1],D[2][N-1]) + W[0][N]  경우 3: N번째 숫자에서 두 번째 행을 선택했을 경우 N-1번째의 아무것도 선택 안했을 경우최대값과,  N-1번째의 첫 번째 행을 선택했을 경우의 최대값중 큰값과 두 번째 행 W[1][N]을 더한다  D[2][N] = max(D[0][N-1],D[1][N-1]) + W[1][N]    코드  func solve(n: Int, arr: [[Int]]) {     let size = n     var res = [[Int]](repeating:[Int](repeating:0, count: size), count: 3)     res[1][0] = arr[0][0]     res[2][0] = arr[1][0]     for i in 1 ..&lt; size {         res[0][i] = max(max(res[1][i-1], res[2][i-1]), res[0][i-1])         res[1][i] = max(res[0][i-1], res[2][i-1]) + arr[0][i]         res[2][i] = max(res[0][i-1], res[1][i-1]) + arr[1][i]     }          let result = max(max(res[0][size - 1], res[1][size - 1]), res[2][size - 1])     print(result) }  if let tc = Int(readLine()!) {     for _ in 0 ..&lt; tc {         let size = Int(readLine()!)!         let col1 = readLine()!.split(separator: \" \").map { Int(String($0))! }         let col2 = readLine()!.split(separator: \" \").map { Int(String($0))! }         var arr = [[Int]]()         arr.append(col1)         arr.append(col2)         solve(n: size, arr: arr)     } }  ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ-9465-DP/",
        "teaser": null
      },{
        "title": "[백준 2156] 포도주 시식",
        "excerpt":"문제  링크   풀이   정의  W[N] : N번째 포도주의 양   D[N] : N번째에서 최대로 마실 수 있는 포도주 양  ex) D[1] : 1번쨰에서 최대로 마실 수 있는 포도주의 양은 6이다                   index       0       1       2       3       4       5       6                       W[N]       0       6       10       13       9       8       1               처음부터 한번 수식을 세워보자!  D[0]  일 때 : 0   D[1] 일 때 : 1잔을 마시는게 최대값 즉, W[1]   D[2] 일 때 : 2잔을 모두 마시는게 최대값 즉, W[1] + W[2]   D[3] 일 때 : 총 3가지의 경우의 수가 있다.      안마시는 경우, 이땐 D[2]가 최대값이 된다     연속 1잔만 마시는 경우, 이전에 마시면 연속 2잔이 되기 때문에 이때는 W[1] + W[3]    연속 2잔 마시는 경우, 이전전에선 마시면 안된다! W[2] + W[3] + W[0]    이제 조금 정리를 해보자.  연속 1잔만 마시는 경우 : W[1]+W[3] -&gt; D[1] + W[3]과 같다   연속 2잔 마시는 경우 : W[2] + W[3] + D[0]과 같다   즉, D[3]일 때 3가지 경우의 수식은       D[3] = D[2]   D[3] = D[1] + W[3]   D[3] = W[2] + W[3] + D[0]   이 3가지 경우의 수 중 최대값을 구하면된다.   코드로 짤수 있도록 [숫자]를 n으로 변경해보자   예를 들어 D[3] = D[n] 이면, D[2]는 3-1 = 2이므로 D[n - 1]이 된다      D[n] = D[n - 1]   D[n] = D[n-2] + W[n]   D[n] = W[n -1] + W[n] + D[n - 3]   이제 이 수식을 이용해 코드를 짜보자!   코드  func solve(n: Int){     var wines = [Int](repeating: 0, count: n + 1)     var dp = wines          for i in 1 ... n {         wines[i] = Int(readLine()!)!     }          if n == 1 {         print(wines[1])         return      }else if n == 2 {         print(wines[1] + wines[2])         return     }     dp[1] = wines[1]     dp[2] = wines[1] + wines[2]          for i in 3 ... n {         var maxWines = dp[i - 1] // 0 잔 마실 때         maxWines = max(maxWines, dp[i - 2] + wines[i]) // 1잔 마실때 vs 0잔 마실 때 최대값 비교         dp[i] = max(maxWines, dp[i - 3] + wines[i] + wines[i - 1]) // 2잔 마실 때와 위의 결과값 비교     }          print(dp[n]) }  ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ2156-DP/",
        "teaser": null
      },{
        "title": "[백준 11053] 가장 긴 증가하는 수열",
        "excerpt":"문제  링크   풀이   W[n] : n 번째에 위치해있는 정수                   1       2       3       4       5       6                       10       20       10       30       20       50           D[n] : n의 위치에서 끝나는 최장 길이 수열    k : 0 ~ n - 1까지의 수라고 정의할 때   W[k] &lt; W[n] 일 경우   D[n] = max(D[n], D[k] + 1)로 갱신한다    코드   func solve() {     let arr = readLine()!.split(separator: \" \").map { Int(String($0))! }          var dp = [Int](repeating: 1, count: arr.count)          for i in 0 ..&lt; arr.count {         for j in 0 ..&lt; i {             if arr[i] &gt; arr[j] {                 dp[i] = max(dp[i], dp[j] + 1)             }         }     }          print(dp.max()!) }  ","categories": ["Algorithm"],
        "tags": ["DP","LIS"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ11053-DP/",
        "teaser": null
      },{
        "title": "이진 탐색",
        "excerpt":"배경  정렬된 배열에서 원소 x를 찾고자 할 때 사용       찾고자 하는 x를 중간 원소와 비교   x가 중간 원소보다 크다면 오른쪽 절반을   x가 중간 원소보다 작다면 왼쪽 절반을 재탐색한다   1 ~ 3과정을 x를 찾거나 부분 배열의 크기가 0이 될 때까지 반복한다   코드   func binarySearch(arr: [Int], find: Int) -&gt; Int {     var low = 0     var high = arr.count - 1     var mid : Int          while low &lt;= high {         mid = (low + high) / 2         if arr[mid] &gt; find {             high = mid - 1         }else if arr[mid] &lt; find {             low = mid + 1         }else {             return mid         }     }     return -1 }   ","categories": ["Algorithm"],
        "tags": ["Search","LIS"],
        "url": "https://sweetfood-dev.github.io/algorithm/binary-search-DP/",
        "teaser": null
      },{
        "title": "[백준 11055] 가장 큰 증가 부분 수열",
        "excerpt":"문제  링크   풀이   가장 긴 증가하는 수열 문제와 비슷하다.  다만 길이가 아니라 합이 라는게 차이 .    따라서 가장 긴 증가하는 수열의 코드에서 if 조건문의 수식만 살짝 바꿔주면 된다    정의를 살펴 보면  arr[n] : 문제의 입력으로 주어진 배열, n번째 숫자  map[n] : n번째 에서 가장 큰 수열의 합  k = 0 ..&lt; n 까지의 인덱스    따라서 수식은   map[n] = max(map[n], arr[n] + map[k])     위에 정의된 수식을 2중 포문으로 탐색한다   코드  // 0 부터 배열의 마지막 인덱스까지 탐색 for i in 0 ..&lt; arr.count {  // 자기 자신은 부분 수열의 합에 항상 들어감 \tmap[i] = arr[i]  \t// 0 ~ i - 1까지 탐색 , j == k( 위에 정의한 k를 j로 사용) \tfor j in 0 ..&lt; i {  \t// i 인덱스의 값보다 j 인덱스의 값이 작으면 부분 수열에 포함  \t\tif arr[i] &gt; arr[j] {  \t\t// 현재 map[i]값 보다 arr[i] + map[j]의 값이 더 크면 더 큰 부분 수열의 합 \t\tmap[i] = max(map[i], arr[i] + map[j])  \t} }   최종 코드는 아래와 같다   func solve(n : Int) {     let arr = readLine()!.split(separator:\" \").map { Int(String($0))! }     var map = [Int](repeating:0, count: n + 1)          for i in 0 ..&lt; arr.count {         map[i] = arr[i]         for j in 0 ..&lt; i {             if arr[i] &gt; arr[j] {                 map[i] = max(map[i], map[j] + arr[i])             }         }     }          print(map.max()!) }  ","categories": ["Algorithm"],
        "tags": ["DP","LIS"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ11055-DP/",
        "teaser": null
      },{
        "title": "[백준 11722] 가장 긴 감소하는 부분 수열",
        "excerpt":"문제  링크   풀이  이전 문제 11053, 11055와 사실상 같은 문제  11053  11055    코드  func solve(n : Int) {     let arr = readLine()!.split(separator: \" \").map { Int(String($0))! }     var map = [Int](repeating:1, count: n)          for i in 0 ..&lt; arr.count {         for j in 0 ..&lt; i {             if arr[i] &lt; arr[j] {                 map[i] = max(map[i], map[j] + 1)             }         }     }          print(map.max()!) }  ","categories": ["Algorithm"],
        "tags": ["DP","LIS"],
        "url": "https://sweetfood-dev.github.io/algorithm/BOJ11722-DP/",
        "teaser": null
      },{
        "title": "[Swift] ARC 및 참조 타입",
        "excerpt":"ARC Swift에서 메모리를 자동으로 관리   특정 객체가 참조되면 참조 카운트(Reference Count, RC)를 1증가 시키고, 모든 참조가 해제되어 0이 되면 메모리에서 해제시킨다.  컴파일 단계에서 실행되고 이 때문에 추가 자원 즉, 오버헤드가 있는 GC 대비 효율적이지만  참조 순환 즉, Memory Leak을 발생시킬 수 있다      순환 참조가 발생하는 경우      프로퍼티에서 인스턴스를 서로 강하게 참조    class App {     var os : iOS?          deinit {         print(\"app deinit\")     } }  class iOS {     var applications : App?          deinit {         print(\"ios deinit\")     } }  var app : App? = App() var ios : iOS? = iOS()  app?.os = ios ios?.applications = app   app = nil ios = nil   위 코드에서 각각 프로퍼티 os, applications가 App, iOS 인스턴스를 참조하여  App, iOS의 RC는 1씩 증가한 1인 상태이다  그 상태에서 참조 변수 app,ios가 nil로 변경되어 프로퍼티에 접근할 수 없어 순환참조가 발생하여 Memory Leak발생          클로저에서 참조하는 경우      class App {     var os : iOS?     let name : String          init(name: String) {         self.name = name     }          lazy var info: () -&gt; String = {         return self.name     }     deinit {         print(\"app deinit\")     } }  var app : App? = App(name: \"Wallet\") app = nil    위의 경우처럼 info 안에서 self를 참조 하고 있을때,   참조변수 app을 nil로 변경되면 클로저와 인스턴스 사이 순환참조가 발생된다        순환 참조 방지 하는 방법       weak, unowend 사용            해당 키워드들로 인스턴스를 참조시 RC가 증가하지 않는다       weak은 아래서 설명하겠지만 옵셔널 타입으로 옵셔널 바인딩, 체이닝을 사용하여 런타임 크래시를 방지할 수 있다       unowend는 생명주기가 길거나 인스턴스가 존재함을 확신할 때 사용된다           클로저에서 캡처리스트 작성            캡처리스트란 클로저가 참조하는 대상, 참조하는 방식을 지정하는 형식이다       즉, 강하게 캡처(참조)할지 약하게 캡처(참조)할지 지정이 가능하다             참조 방식     strong            객체를 소유하여 RC를 증가시키는 프로퍼티       ARC로 인한 메모리 해제를 피하고 객체를 안전하게 사용할 때 사용           weak            객체를 소유하지 않고 주소값만을 가지고 있는 포인터 개념       메모리에서 해제될 경우 자동으로 nil로 초기화되기 때문에 옵셔널 타입으로 사용해야한다           unowend            weak과 비슷한 개념이지만 nil값이 될 수 없기 때문에 옵셔널 타입으로 선언하면 안된다           잘못된 설명이 있으면 지적 부탁드립니다.   ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/ARC/",
        "teaser": null
      },{
        "title": "[Swift] 클로저",
        "excerpt":"클로저         클로저의 형태            이름을 가진 어떤 값도 캡처하지 않는 전역 함수       이름을 가진 자신을 감싸고 있는 함수에서 값을 캡쳐해 가질 수 있는 중첩 함수       이름이 없으며 주변 환경의 값을 캡처해 가질 수 있는 클로저 표현식           @escaping            인자값으로 전달된 클로저를 저장해 두었다가 다른 곳에서도 실행할 수 있도록 허용해주는 속성       인자값으로 전달된 클로저는 기본적으로 탈출불가의 성격을 가진다       이는 함수 내에서, 직접 실행을 위해서만 사용해야하는 것을 의미한다       중첩된 내부 함수에서도 사용이 불가하다           func outerFunc( c: () -&gt; () ) -&gt; () -&gt; (){     c()     func innerFunc() {         c()     } \t\t// innerFunc() 안에서 매개변수 c를 호출하고 있기 때문에 에러 발생     return innerFunc  }   let inner = outerFunc {     print(\"run func\") }   inner()   이러한 제약조건을 모두 제거하여 사용 가능 하게 만들어 주는 것이 @escaping 속성이다  아래와 같은 상황에서 사용       완료에 따른 처리   비동기로 실행 시 함수 사이의 실행 순서를 정할 수 있음              값의 캡처           클로저 내부에서 사용되는 외부 변수의 값을 내부적으로 저장, 이를 캡처되었다고 한다   클로저에서의 캡처는 value type이여도 reference 캡처(카피)를 한다. 변수가 사용되는 시점의 값을 캡처   단, capture list를 이용하면 value 카피로 사용 가능하다.   value 캡쳐된 값은 클로저안에서 변경이 불가하다   Reference Capture   var anInteger = 42 let testClosure = {     // anInteger는 capture되는 순간 reference copy됨     print(\"Integer is: \\(anInteger)\") } testClosure() // \"Integer is 42\" anInteger = 84  testClosure() // \"Integer is 84\"   Value Capture   var anInteger = 42  let testClosure = { [anInteger] in     // anInteger는 capture되는 순간 value copy됨     print(\"Integer is: \\(anInteger)\") } testClosure() // \"Integer is 42\" anInteger = 84  testClosure() // \"Integer is 42\"   ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/Closure/",
        "teaser": null
      },{
        "title": "[Swift] defer",
        "excerpt":"defer        작성된 위치와 순서에 상관없이 함수가 종료되기 직전에 호출된다   defer블록을 읽기전에 함수가 종료되면 defer블록은 실행되지 않는다.   defer 블록은 여러번 사용가능하다. defer문을 만나면 순차적으로 스택에 저장되고 스코프 종료 후 하나씩 pop해서 실행하기에 마지막 defer문 부터 역순으로 실행된다   defer 블록은 중첩으로도 사용 가능하다. 이때 순서는 바깥쪽 defer문으로부터 안쪽 defer문의 순서로 실행된다  ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/defer/",
        "teaser": null
      },{
        "title": "[Swift] 클래스와 구조체",
        "excerpt":"               Class       Struct                       레퍼런스 타입       밸류 타입                 객체화시 힙영역에 저장되고 그 주소값은 스택 영역에 저장, ARC로 메모리 관리       스택 영역에 저장                 상속가능       상속 불가, Protocol은 사용가능하다                 대입 연산 시 레퍼런스 공유       대입 연산 시  값 복사          ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/02-Class-Struct/",
        "teaser": null
      },{
        "title": "[Swift] as as? as!",
        "excerpt":"                       설명       실행 시점       캐스팅 종류                       as       컴파일러가 타입 변환의 성공을 보장       컴파일 타임       업 캐스팅                 as?       변환에 실패하는 경우 nil을 반환       런타임       다운 캐스팅                 as!       변환에 실패하는 경우 런타임에러 발생       런타임       다운 캐스팅          ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/1-type-casting/",
        "teaser": null
      },{
        "title": "[Swift] Lazy",
        "excerpt":"Lazy란     처음 사용되기전까지 연산이 되지 않습니다.     고려 사항      항상 var 키워드와 함께 사용            처음에는 아무 값이 없고 추후 사용될 때 값이 할당되기 때문에 let은 사용할 수 없습니다           구조체, 클래스에서 사용 가능   연산 프로퍼티에는 사용 불가            처음 사용 될 때, 메모리에 값을 올리고 이후에 사용 될 때는 메모리에 올린 값을 사용하기 때문에  사용할 때마다 연산이 되는 연산프로퍼티에서는 사용할 수 없습니다           클로저에서의 사용            클로저의 결과값으로 사용 될 때는 실행 이후 종료되기 때문에 메모리 누수의 걱정이 없지만       클로저 자체를 사용할 때는 클로저 리스트를 사용해 메모리 누수 방지를 해줘야 합니다          ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/5-Lazy/",
        "teaser": null
      },{
        "title": "CollectionViewLayout",
        "excerpt":"UICollectionViewLayout  일반적인 collectionview의 delegate와 datasource는  화면에 셀을 표시하는 역할을 담당합니다  표시 할 때 구성과 같은 layout은 UICollectionViewLayout을 구현하여 처리해야합니다    커스텀 CollectionViewLayout의 주 역할은 UICollectionView에서 요청하는 레이아웃 관련 정보를 제공하는 것입니다.  레이아웃을 미리 준비해 놓았다가 UICollectionView에서 요청하면 준비한 레이아웃 정보를 제공합니다.  이 때 몇가지 필수 메소드들이 존재합니다     prepare()     UICollectionView에 표시되는 전체 크기를 계산하고 각 셀의 레이아웃 속성, collectionView의 크기와 cell의 위치를 미리 계산(캐싱)하여 메모리에 적재한 뒤 유지합니다.   collectionViewContentSize     collectionView의 전체 높이와 너비를 반환합니다.   화면에 보이는 contents 뿐만 아니라 collectionView의 전체를 반환해야 합니다.   collectionView는 이 정보를 활용하여 내부적으로 scrollView의 크기를 구성합니다.   layoutAttributesForElements (in :)     in의 범위 안에 있는 모든 셀들의 레이아웃 속성들을 배열에 담아 반환합니다   layoutAttributesForItem (at :)     at으로 들어온 cell의 레이아웃 속성을 반환합니다.   호출 순서  Layout prepare() : 전체 크기, 셀의 위치를 미리 계산  collectionView numberOfItemsInSection : 아이템의 전체 개수  Layout collectionViewContentSize : collectionView의 전체 크기(너비, 높이)  Layout layoutAttributesForElements : 범위 안에 있는 모든 셀들의 레이아웃 속성  Layout collectionViewContentSize :  collectionView의 전체 크기(너비, 높이)  collectionView cellForItemAt : cell 표시   ","categories": ["iOS"],
        "tags": ["UICollectionView"],
        "url": "https://sweetfood-dev.github.io/ios/1-custom-layout/",
        "teaser": null
      },{
        "title": "UICollectionViewDataSourcePrefetching",
        "excerpt":"UITableView/UICollectionView 에서 Pagenation을 위해 보통 아래 방법을 사용했다.    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {         if indexPath.row == myItemList.count - 1 {             fetchNextPage()         }     }    보여지는 Cell을 기준으로 List 의 마지막 아이템을 부르기 전에 다음 리스트 호출을 하는 식이다.  하지만 이번에 과제를 하면서 너무 버벅여 다른 방법을 찾아봤는데, UICollectionViewDataSourcePrefetching 프로토콜이 존재하였다  ‘willDisplay’ 이 실제 보여지는 Cell을 기준으로 한다면 prefetchDataSource 는 이 작업을 백그라운드로 옮겨와 처리하는 것이다.    extension ViewController: UICollectionViewDataSourcePrefetching {     func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) { \t\t//내용      } }   이렇게 수정 후 눈에 띄게 속도가 향상되었다!!!  ","categories": ["iOS"],
        "tags": ["UICollectionView"],
        "url": "https://sweetfood-dev.github.io/ios/2-UICollectionViewDataSourcePrefetching/",
        "teaser": null
      },{
        "title": "Application 생명 주기",
        "excerpt":"App 생명주기란     앱의 실행부터 종료까지의 주기를 말하며, 앱이 foreground나 background에 있을 때 시스템 알림에 응답하고 기타 중요한 시스템 관련 이벤트를 처리하는 단계들을 말한다.       앱 실행시   UIAppliation 객체를 생성한다.  이후 UIApplication 어노테이션이 있는 객체를 찾아 AppDelegate를 생성한다.  Main Run Loop ( Main Event Loop)를 실행하고  Main Run Loop는 발생한 이벤트를 큐에 담아놓고  담겨 있는 이벤트를 꺼내 하나하나 실행하여 처리한다  AppDelegate 객체는 Life Cycle을 전달 받기 때문에 이를 통하여 현재 상태를 알 수 있다    Life Cycle   Not Running     아무 것도 하지 않는 상태 혹은, 실행 중이나 시스템에 의해 종료된 상태   In-Active     상태 전환 과정에서 잠시 머무르는 상태   Active     실제 앱이 실행 되는 상태( 이벤트를 받는 단계 )   BackGround     Suspend 진입 전에 거치는 단계   데이터의 저장등의 작업을 처리한다   일반적인 앱은 잠시 머물고 바로 Suspend상태로 진입하지만   음악, 통화, 녹음등의 앱은 이 상태에서도 동작한다   Suspend     BackGround 상태지만 아무 실행도 하지 않는 상태, Not Running 상태와 같다   시스템이 임의로 BackGround상태를 Suspend로 만든다 ( 리소스 해제 )  ","categories": ["iOS"],
        "tags": ["Lifecycle"],
        "url": "https://sweetfood-dev.github.io/ios/3-App-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/",
        "teaser": null
      },{
        "title": "ViewController 생명 주기",
        "excerpt":"생명주기  iOS에서는 화면전환을 할 때 기존의 화면 위에 새로운 화면을 쌓는 식으로 화면 전환을 합니다.  이 때 각각의 ViewController는 자신만의 생명주기를 가지고 있습니다  그래서 상황에 맞는 함수들이 호출 되는데 이 생명주기를 나타내는 대표적인 메소드들은 다음과 같습니다     ViewDidLoad     ViewController 클래스가 생성될 때 딱 한번 실행됩니다.   보통 초기화 작업이 이루어집니다     ViewWillAppear       화면에 나타나기 직전에 실행됩니다   ViewDidload와 다르게 나타나기 직전마다 항상 실행됩니다     ViewDidAppear       화면에 나타난 직후에 실행됩니다.     ViewWillDisAppear       화면에서 사라기지 직전에 실행됩니다     ViewDidDisAppear       화면에서  사라지고 난 직후에 실행됩니다  ","categories": ["iOS"],
        "tags": ["View","Lifecycle"],
        "url": "https://sweetfood-dev.github.io/ios/3-ViewController-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[iOS] Frame과 Bounds",
        "excerpt":"Frame      상위뷰 좌표 시스템 내에서 View의 위치와 크기      Bounds      자기 자신의 좌표시스템에서의 (sub view들의)위치와 크기, 부모뷰와는 관계가 없다   default origin은 0,0이다   origin의 변경은 sub view들의 위치가 변경됨을 의미   sub view의 위치가 변한다는 것은 그려져야하는 위치가 달라지는 것이지 sub view들의 frame 값의 변화는 없다   스크롤 시 sub view들의 위치가 달라지는 것이 대표적인 예이다  ","categories": ["iOS"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/ios/3-frame-bounds/",
        "teaser": null
      },{
        "title": "GCD",
        "excerpt":"GCD란     Apple에서 제공하는 멀티쓰레드 처리 API      DisPatchQueue가 GCD에 존재합니다  DisPatchQueue는 메인스레드 / 백그라운드 스레드에서 작업실행을 관리하는 객체입니다  순차적으로 실행하는 Main Queue와 동시에 실행하는 Global Queue를 포함하고 있습니다    종류     Main Queue            보통 UI관련된 처리를 담당하고 앱이 실행 되었을 때 자동으로 실행됩니다           Gloabal Queue            백그라운드에서 동작하고       동시에 작업을 수행합니다.       메인큐 작업에 영향을 주면 안되는 작업을 처리할 때 사용하며       QoS를 통해 작업의 우선순위를 부여할 수 있습니다.          ","categories": ["iOS"],
        "tags": ["Thread"],
        "url": "https://sweetfood-dev.github.io/ios/4-GCD/",
        "teaser": null
      },{
        "title": "오토레이아웃의 우선순위",
        "excerpt":"constraint의 priority      제약 사항간의 우선순위   뷰들의 크기가 유동적으로 변할 때, 제약들간에 충돌이 발생할 수 있다   이 때 우선순위를 결정함으로 충돌을 해결할 수 있다.  ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/4-autolayout-priority/",
        "teaser": null
      },{
        "title": "아키텍처",
        "excerpt":"왜 아키텍처를 사용해야하지?   개발을 하다보면 디버깅을 해야하는 상황이 필연적으로 찾아온다  이 때 프로젝트의 몸집이 크다면 디버깅을 하는데 있어 어려움을 겪게 될 것이다  구조적으로 잘 정의된 프로젝트는 디버깅을 쉽게 해주며, 개발자간의 의사소통, 유지보수에도 도움이 된다!    좋은 아키텍쳐의 특징     객체간 책임 분리가 균형있게 잡혀 있고 명확하게 이루어저야 한다.   테스트가 용이해야 한다        사용이 용이해야 한다. 즉 유지 보수가 쉬워야 한다.       책임 분리는 왜 이루어 저야 할까?  로직을 쉽게, 단순하게 한눈에 볼 수 있다  즉, 복잡함을 극복하는 방법은 단일책임 원칙으로 책임을 나누는 것이다!    왜 테스트가 가능해야 할까?  런타임 내에서 이슈를 찾는것을 도와준다  실사용자가 이슈를 접한다면 그 이슈를 수정하는데 오랜 시간이 걸리니까, 미연에 방지해야한다!    사용의 용이  단순하다. 유지보수가 용이하니까!    어떤 아키텍쳐들이 있는데?  기본적으로 많이 접해본 mvc, mvp, mvvm, viper가 있고 이러한 아키텍쳐는   3가지 카테고리(요소)를 포함한다                   요소       설명                       Model       데이터, 데이터 접근자                       View       화면에 표시되는 UI적인 요소                       Controller,Presentor,ViewModel       model과 View를 붙여준다                         View의 액션을 처리하여 Model을 변경하거나                         Model이 변경되었을 때 View를 갱신하는 책임을 가진다           이러한 구성을 통해 이해가 용이, 재사용이 가능, 독립적으로 테스트가 가능한 이점을 얻을 수 있다!  다음 포스트를 통해 mvc 부터 차근차근 알아보자!  ","categories": ["iOS"],
        "tags": ["Architecture"],
        "url": "https://sweetfood-dev.github.io/ios/1-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/",
        "teaser": null
      },{
        "title": "MVC 패턴",
        "excerpt":"설명  Apple의 MVC를 학습하기전에 전통적인 MVC에 대해 알아보자!       그림을 보면 MVC가 모두 밀접하게 연관되어 있다  이는 곧 재사용성이 떨어짐을 의미한다  그만 알아보자  전통적인 MVC는 iOS에 적합해 보이지 않는다!    Apple이 권고하는 MVC에 대해 알아보자.     그림에서 볼 수 있듯 Controller는 중간에서 Model과 View를 이어준다  Model – View는 서로 알 필요가 없다  Controller는 여전히 재사용이 어려워 보인다    한계  위의 그림과 대조적이게 실제로 Cocoa MVC는 다음 그림과 같다     왜 위와 같이 구성될까?      Controller는 View를 가지고 있다.(그래서 이름도 ViewController다)   따라서 View의 생명 주기와 Controller의 분리가 사실상 어렵다   이렇게 View를 가지고 있고, 그 생명주기도 관리하기 때문에 Controller자체가 거대해진다   좋은 아키텍쳐 특징에서 바라보기  좋은 아키텍처의 특징, 요소 측면에서 이 패턴을 파악해보자!      책임 분리            View와 Controller의 관계가 매우 밀접하여 , 책임분리가 안된다           테스트            View와 Controller의 밀접한 관계로 인해 사실상 Model만 테스트가 가능하다.           사용 용이성            코드길이는 적고, 진입장벽 자체는 낮다!           정리     개발속도가 빠르기에 아키텍처에 투자할 시간이 부족할 때 사용하면 유용하다   유지보수 비용이 많이 들어가는 편이다   MVC가 개발속도는 짱이다! 그러나 유지보수 비용은 많이 들어간다!  ","categories": ["iOS"],
        "tags": ["Architecture"],
        "url": "https://sweetfood-dev.github.io/ios/2-MVC/",
        "teaser": null
      },{
        "title": "MVP",
        "excerpt":"설명  MVC에 이어 MVP를 알아보자     기본적으로 MVC와 유사하다  차이점은 ViewController가 View와 함께 Passive View에 속해있다는 점!  presenter는 Model과 Passive View 사이에 다리 역할을 하며   이로 인해 MVC에서의 문제였던 View의 생명 주기에서 자유로울 수 있다   View는 이로 인해 데이터와 상태를 갱신하는 역할에 집중 할 수 있다  같은 이유로 View도 Test가 가능하게 되었다  다만 View의 갱신, 이벤트 처리에 대한 메소드 바인딩이 이루어저야 하여  개발비용이 MVC보다 더 많이 든다!    좋은 아키텍처 특징에서 보기     책임 분배 : Presenter와 Model을 완벽하게 분리하고 View는 단순히 출력하는 용도로 분리 되었다   테스트 : View의 재사용이 가능하여 대부분의 로직을 테스트할 수 있다   사용 용이성 : 코드는 MVC에 비해 늘어나지만 각 요소들의 역할이 더 명확해 진다   iOS에서 테스트를 하기에 좋다!, 다만 코드는 길어진다!  ","categories": ["iOS"],
        "tags": ["Architecture"],
        "url": "https://sweetfood-dev.github.io/ios/3-MVP/",
        "teaser": null
      },{
        "title": "MVVM",
        "excerpt":"설명  MVVM 패턴은 MVP와 비슷하다     ViewController를 MVP에선 PassiveView로 보앗듯이   MVVM에서는 View로 본다  View와 Model이 연결되지 않는다   View와 ViewModel사이를 바인딩으로 연결해 준다  다만 구조자체가 복잡하기 때문에 디버깅이 비교적 오래 걸린다     ViewModel이란?  View의 독립된 표현 혹은 상태를 말한다  Model에서 변경을 호출하고 Model 자체를 갱신한다  View와 Model 사이에서 바인딩을 하여 갱신한다    좋은 아키텍쳐 특징에서 보기     책임분배 : MVVM에서의 View는 MVP의 View보다 책임지는 것이 더 많다   테스트 : ViewModel은 View에 대해 전혀 모르기 때문에 테스트가 용이하다   사용용이성 : MVP보다 비교적 적은 코드로 개발할 수 있다   View 입장에서 바인딩을 하기 때문에 View를 갱신하는데 추가 코드가 필요하지 않다!  테스트에도 좋은 난이도 있는 아키텍처  ","categories": ["iOS"],
        "tags": ["Architecture"],
        "url": "https://sweetfood-dev.github.io/ios/4-MVVM/",
        "teaser": null
      },{
        "title": "간편하게 포스트 하는 법?",
        "excerpt":"터미널에서 로컬의 gitblog 폴더로 이동!   jekyll serve 실행     http://localhost:4000/admin     편하게 글 올리자!  ","categories": [],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/GitBlog_Post/",
        "teaser": null
      },{
        "title": "[Swift] Optional",
        "excerpt":"옵셔널이란? : 값이 없을 수 있는 상황에서 Optional을 사용한다.     옵셔널로 사용할 Type뒤에 ?를 붙여 사용한다.    var number : Int? // Int 옵셔널  var text : String? // String 옵셔널   값이 없을 수 있다는 것은 무슨 의미일까?   String  값을 Int로 변환을 해야하는 경우 아래처럼 사용할 수 있다.   var test: Int = Int(\"123\") // test = 123   하지만 다음과 같은 경우엔?  var test: Int = Int(\"Hello World\") // test = ??  변환 할 수 없을 것이다. 이때 변환할 수 없음, 값이 없음이란 의미로 nil이란 값을 반환할 것이다     // var test: Int = Int(\"Hello World\")  var test: Int? = Int(\"Hello World\") // test = nil  주석 처리한 코드와 그 밑에 코드를 보면 ?가 달려 있는걸 알 수 있다   이 물음표는 해당 타입이 옵셔널이라는 것을 나타낸다!     정리하자면 Optional은 변수 혹은 상수에 값이 없음을 나타낼 수 있게 만들어 주고 값이 없는 상태는 nil로 표현한다!      이 nil 이란 놈은 이전 obj-c에서도 사용했었던 것 같은데 obj-c와 Swift에서의 nil은 같은 의미로 사용되는걸까?   기억에 obj-c에서는 따로 Optional이라는 개념이 없었던 것 같다.    obj-c에서의 nil은 유효한 객체가 없음의 의미로 쓰인다고 한다.   Swift에서의 nil은 값이 없음을 의미한다는데 같은 뜻 아닌가? 라고 할 수 있지만 객체와 값은 아주 큰 차이다  obj-c에서의 nil을 좀 더 풀어 말하면 존재하지 않는 객체에 대한 포인터라고 나와있다.   즉 obj-c 에서 nil은 객체 type에 대해서만 사용이 가능하다란 것이다. obj-c에서 일반 타입에 대한 값 없음은 NSNotFound라는 특수 값을 반환하여 나타낸다고 한다!    obj-c와 Swift의 nil의 차이점을 정리하자면,                           Obj-c       Swift                       의미       유효한 “객체”가 없음(포인터)       “값” 없음                 사용 가능한 Type       객체       모든 유형 ( 객체, 구조체, 열거형등등)          ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/Optional/",
        "teaser": null
      },{
        "title": "[Swift] 옵셔널의 사용",
        "excerpt":"이전글 Optional에서는 Optional과 nil에 대해 알아 보았다    옵셔널을 사용하기 위해 아래와 같은 코드를 실행해보았다   Swift는 Type에 대해 엄격하다. Int Type과 Int? Type은 엄연히 다른 타입이다.  Int type으로 선언된 변수에는 Int? type의 값이 들어 갈 수 없다. 그렇다면?  옵셔널을 해제 해주어야 한다.  그렇다면 어떻게 해제를 하여 사용하는지 알아보자!!    1.  if문과 강제 언래핑   if 문을 사용하여 옵셔널과 nil을 비교하여 옵셔널에 값이 있는지, 아니면 없는지(nil)를 확인할 수 있다   if 문에서 nil 이 아닐 때 print가 실행이 된다. 그럼 print가 되었을때 옵셔널 변수의 값은 어떨까?   optional 변수인 convertedNumber는 Optional(123)이 출력되고, 일반 Int 타입의 변수 intTypeNumber은 123이 출력된다.  Optional(123)에서 괄호 안에 있는 123을 꺼내 사용하고 싶다면?  변수명 이름뒤에 ! 만 붙이면 된다   ! 를 붙여 Optionald 해제하는 것을 강제 언래핑 이라고 한다. 이 강제 언래핑을 사용할 때에는 항상 nil인지를 확인 후에 사용해야한다. 만약 확인을 하지 않았을 때 변수가 nil인 상태라면 런타임 오류가 발생할 것이다!    2.  Optional Binding    옵셔널을 해제 하는 또 다른 방법엔 옵셔널 바인딩이 있다.  옵셔널 바인딩을 사용하면 옵셔널에 값이 있는지 확인하고 값이 있다면해당 값을  임시 상수나 변수로 추출하여  사용할 수 있다  이 때, 추출된 값은 옵셔널이 해제된 순수한 값이므로 일반 변수처럼 사용 가능하다.   // Optional Binding의 형태 if (let 혹은 var) 추출 후 사용할 변수 = 옵셔널 변수 {     // 코드 실행 }  강제 언래핑에 사용한 예제 코드를 옵셔널 바인딩 형태로 변경 하면 다음과 같다  let possibleNumber = \"123\" if let actualNumber = Int(possibleNumber) {     print(\"문자열 \\(possibleNumber)은 Int \\(actualNumber) 이다!\") }else {     print(\"문자열 \\(possibleNumber)는 Int로 변환할 수 없다\") }  Int(possibleNumber)가 반환하는 옵셔널 Int에 값이 있으면 해당 값을 추출하여 actualNumber에 설정해라!  actualNumber에 값이 들어가 있다면 해당 if문 안에서는 일반 상수처럼(var로 선언하였다면 변수) 사용이 가능하다!  ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/Optional2/",
        "teaser": null
      },{
        "title": "[Swift] 옵셔널 체이닝 (Optional Chaining)",
        "excerpt":"옵셔널 체이닝 (Optional Chaining)   옵셔널 체이닝은 nil일 수도 있는 프로퍼티나 메소드, 서브스크립트에 질의를 하는 과정을 말한다.   기본 동작은 옵셔널과 마찬가지고 값이 있으면 값을 반환, 값이 없다면 nil을 반환한다. 여러 질의를 연결할 수도 있는데 연결된 질의에서 어느 하나라도 nil이면 전체 결과는 nil이 된다.   // query1, query2 중 하나라도 값이 nil이라면 result는 nil이 된다 let result = query1?.query2?.query3    강제 언래핑의 대체로써의 옵셔널 체이닝   위 코드에서 보이듯 옵셔널 체이닝은 옵셔널 값 뒤에 물음표(?)를 붙여서 표현한다. 강제 언래핑을 했는데 만약 그값이 없으면(nil 반환) 런타임 에러가 발생하지만, 옵셔널 체이닝을 사용하면 런타임 에러대신 nil이 반환된다.   옵셔널 체이닝에 의해 nil 값이 호출 될 수 있기 때문에 옵셔널 체이닝을 사용한 구문의 값은 항상 옵셔널이 된다.   코드를 보면서 이해해보자   class Person {     var residence: Residence? }  class Residence {     var numberOfRooms = 1 }   Residence는 Int 프로퍼티(numberOfRooms)를 소유하고 있고 Person은 옵셔널 프로퍼티(residence)를 소유하고 있다.   let john = Person()   john은 Person 인스턴스이고 이 시점에서 john의 residence는 nil로 초기화 되어있을 것이다.   근데 이 때 강제 언래핑을 사용한다면?   let roomCount = john.residence!.numberOfRooms // runtime error   당연하게도 런타임 에러가 발생할 것이다.   이를 옵셔널 체이닝으로 한다면 보다 안전하게 접근할 수 있다   if let roomCount = john.residence?.numberOfRooms { // 옵셔널 바인딩!      // 옵셔널 바인딩으로 인해 일반 프로퍼티처럼 사용 가능     print(\"John residence \\(roomCount) room(s)\")   } else { // nil 일 떄      print(\"residence == nil\") }   numberOfRooms는 옵셔널이 아닌데 어째서 옵셔널 바인딩을 사용했나?   앞에서 설명하였듯이 옵셔널 체인으로 접근하는 프로퍼티, 메소드등의 결과는 항상 옵셔널 값이 되기 때문에 이렇게 옵셔널을 벗겨줘야한다.  ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/OptionalChaining/",
        "teaser": null
      },{
        "title": "[Swift] 튜플 (Tuple)",
        "excerpt":"튜플이란?   스위프트 문서에서 직역하자면 여러 값을 단일 복합값으로 그룹화하는 것이다.   말은 어렵지만 여러 Type의 값을 하나로 묶어 사용할 수 있는 것이다.      Type은 배열처럼 모두 같아야 하는건 아니다. 다른 Type끼리도 가능하다    http 상태코드를 예로 들어보자     자주 접할 수 있는 창이다. 여기서 404는 Int이며 File not found는 String이다.   기존에 이러한 데이터는 클래스나 구조체에 담아서 사용 했겠지만 Swift에서는 튜플로 처리가 가능하다!   class HttpStatus { \tvar code: Int? \tvar message: String? }  struct HttpStatus { \tvar code: Int \tvar message: String }   예로 들은 http 상태코드를 튜플로 선언하면 아래와 같다   let httpError = (404, \"Not Found\")   그러하면 여기서 httpError가 튜플인건 알겠는데 어떤 Type일까?      Xcode에서 확인해보면 httpError의 Type은 (Int, String)이다. Int와 String을 하나의 그룹으로 만들어 사용하는 것 그것이 바로 튜플이다.   이제 처음 말했던 튜플이란 여러 값을 단일 복합값으로 그룹화하는 것이라는 말을 이해할 수 있다!   튜플의 사용   let httpError = (404,\"Not Found\") // httpError의 타입은 (Int, String) print(\"httpError is \\(httpError)\") // output : httpError is (404, \"Not Found\")   위에 처럼 httpError를 출력 하였을 때는 튜플 그대로 출력이 된다. 우리가 원하는건 튜플 안의 값이다!   그럼 저 튜플에 있는 값을 어떻게 사용할 수 있을까?   튜플을 각각 분해하여 사용   튜플의 위치에 각각 대응하는 변수나 상수로 분해하여 사용할 수 있다. 무슨말인지 잘 모르겠지만 코드를 보면 금방 이해가 가능할 것이다!   let httpError = (404, \"Not Found\") // (Int, String) type의 튜플 let (statusCode, statusMessage) = httpError print(\"statusCode \\(statusCode)\") // output &gt;&gt; statusCode 404 print(\"statusMessage \\(statusMessage)\") // output &gt;&gt; statusMessage Not Found   httpError를 (statusCode, statusMessage) 튜플에 복사하였다!   튜플의 순서상으로 보면 statusCode는 404가 될 것이고, statusMessage는 “Not Found”가 될 것이다.   우리의 친구 print로 확인해보자      예상대로 잘 나와 주었다!   만약 튜플의 모든 값이 필요 하지 않고 몇개의 값만 필요 하다면 _를 이용하여 생략하여 줄 수도 있다   let (justStatusCode, _) = httpError //  _ 로 생략 가능!   인덱스로 접근   가장 간단한 방법으로 인덱스로 접근이 가능하다.   let httpError = (404, \"Not Found\") // 좌측 부터 인덱스 0으로 시작 print(httpError.0) // 404 print(httpError.1) // Not Found      인덱스를 사용하면 정말 간단하겠지만 아무래도 가독성에는 좋지가 않다.   튜플 정의 시 이름을 지정!   튜플의 값들에 대해 별명을 지어줄 수 있다!   let httpStatus = (statusCode: 200, statusMessage: \"OK\") print(httpStatus.statusCode) // 200 print(httpStatus.statusMessage) // OK   위와 같이 정의할 때 별명을 명시하고 튜플을 생성하면 클래스나 구조체의 프로퍼티에 접근하는 것처럼 사용이 가능하다!     ","categories": ["Swift"],
        "tags": [],
        "url": "https://sweetfood-dev.github.io/swift/Tuple/",
        "teaser": null
      },{
        "title": "[Swift] Array (배열)",
        "excerpt":"Array(배열)이란?   정렬된 목록에 같은 Type의 값을 저장하는 자료구조 Collection이다.   중복된 값이 허용되는 자주 사용하는 자료구조!   Swift에서 Array   Swift에서 배열을 생성하는 기본적인 문법은 다음과 같다   (var / let) 변수명 : Array&lt;Element&gt; = Array&lt;Element&gt;()   여기서 는 배열에 들어가는 Type이다. 예를 들어   var intArray : Array&lt;Int&gt; = Array&lt;Int&gt;() // Int 배열 var stringArray : Array&lt;String&gt; = Array&lt;String&gt;() // String 배열 var doubleArray : Array&lt;Double&gt; = Array&lt;Double&gt;() // Double 배열   이렇듯 Int, String, Double등 모든 Type에 대하여 배열을 만들 수 있고, 추후 공부할 Struct, Class, 프로토콜등의 Type도 배열로 사용할 수 있다. 이러한 형태를 Generic이라고 하는데 이는 추후에 다시 공부할 계획!!   지금은 Array에 집중을 해보자!   기본적인 Array의 선언은 위와 같은데 딱봐도 너무 길다… 좀 줄여 보자 !   Swift는 타입 추론이라는 기능을 지원하는데 이러한 기능은 해당 변수가 어떤 Type인지 명시하지 않아도 Swift가 알아서 척척 해당 Type을 유추해주는 훌륭한 기능이다. 따라서 Type을 생략할 수 있다   // var intArray ~~: Array&lt;Int&gt;~~ = Array&lt;Int&gt;()  var intArray = Array&lt;Int&gt;()   벌써 확 줄어 들었다. 근데 놀라운건 더 줄일 수 있다!!!! 바로 아래와 같이!   var intArray = [Int]()   보통 우리는 Array를 표현할 때, [1,2,3,4,5]로 표현할텐데 이를 형상화 한거 같다!.   [ ] 사이에 Type을 명시해준다! 즉 [Int]!   Array 생성   Swift에서는 Array에 대해 여러 이니셜라이저를 제공한다. 차례대로 알아보자!      이니셜라이저란 초기 값을 생성하는 메소드 혹은 함수 정도로 생각하자!    빈 Array 생성   var intArray = [Int]()   그렇다 위에서 본 코드다!   기본 값을 가진 Array 생성   // repeating:반복하여 넣을 값 , count: 반복하여 삽입할 횟수 var intArray = [Int](repeating: 5, count: 3) // result : [ 5, 5, 5 ]   처음에 이 이니셜라이저를 보고 좀 헷갈렸다, repeating도 반복이고 count도 반복이잖아? 뭐야?   쉽게 생각하자 repeating은 값, count는 repeating의 값을 몇 개나 넣을 것인지..   리터럴 값으로 생성   var shppingList = [\"Eggs\", \"Apple\"]   처음부터 Array에 값을 넣어 주는 방법이다.   다른 Array들로 생성   var threeArray = [3, 3, 3] var twoArray = [2, 2] var oneArray = [1]  var mergeArray = oneArray + threeArray + twoArray // -&gt; [1, 3, 3, 3, 2, 2] 왼쪽부터 오른쪽 Array순으로 !   기존의 배열들을 합쳐서 생성하는 것도 가능하다. 이 때 mergeArray 값들의 순서는 당연하겠지만 왼쪽 Array부터 오른쪽 Array 순으로 값이 들어 간다.   주의할 점은 합칠 Array들의 Type이 모두 같아야 한다! Swift는 Type을 굉장히 엄격하게 관리하기 때문에 기본적으로 모든 연산들은 같은 Type에서 이뤄저야 한다!   let stringArray = [\"문자열 배열\"] let intArray = [1] let mergeArray = stringArray + intArray // 에러에러에러!!!   Array 수정   개발을 하다보면 처음부터 Array에 기본 값이 주어진 상황보다는 빈 Array로 시작해서 추가 하고 필요에 따라 삭제하는 상황이 더 많다.   append   Array의 맨 끝에 Element를 추가 한다!   var shppingList = [\"Eggs\", \"Apple\"] shoppingList.append(\"Banana\") // [\"Eggs\", \"Apple\", \"Banana\"]   insert   지정한 위치에 Element를 추가 한다!   shoppingList.insert(\"Grape\", at:2) // [\"Eggs\", \"Apple\", \"Grape\", \"Banana\"]   연산자를 사용한 다른 Array 추가   += 연산자를 사용하여 다른 Array의 값을 쉽게 추가할 수 있다. ( 물론 같은 Type의 Array이어야한다!)   // 맨 뒤에서 부터 데이터가 추가 된다. shoppingList += [\"배\", \"감\"] // [\"Eggs\", \"Apple\", \"Grape\", \"Banana\", \"배\", \"감\"]   Array 삭제   let removedItem = shoppingList.remove(at: 2) // 2번째 인덱스의 Element 삭제  // _ = shoppingList.remove(at: 2) 생략 가능 // 수행 후 shoppingList 항목 //[\"Eggs\", \"Apple\", \"Banana\", \"배\", \"감\"] // Grape가 삭제   remove(at:) 메소드는 입력한 인덱스의 Element를 삭제하고 그 Element를 반환한다.   _ 키워드로 생략 가능하다.   처음과 마지막 Element를 삭제하는 메소드 또한 존재한다   _ = shoppingList.removeLast() // 마지막 Element 삭제 _= shoppingList.removeFirst() // 첫 Element 삭제   Array의 순회   Array 뿐만 아니라 Set, Dictionary와 같은 Swift의 모든 Collection Type에서는 편리한 순회를 제공한다.   for item in shoppingList {     print(item) }  // 위의 코드는 아래 코드와 같다  for i in 0 ... shoppingList.count {     print(shoppingList[i]) }   짜잔. 가독성도 좋고 코드의 길이도 짧아졌다.   만약 값과 인덱스가 모두 필요한 경우라면 아래와 같은 기능도 지원한다   for (index, item) in shoppingList.enumerated() {     print(\"index : \\(index) item : \\(item)\") }    바로 enumerated() 메소드를 사용하는 것.! 해당 메소드는 (index, value) 튜플을 반환하는데 이를 그대로 튜플로 받아 사용할 수 있다. 참 여러모로 편리하다!   .map, .filter 등과 같은 고차 함수 같은 더 많은 편리한 메소드들이 있다. 이러한 메소드들도 계속 추가하여 다뤄보도록 하겠다!  ","categories": ["Swift"],
        "tags": ["Collection"],
        "url": "https://sweetfood-dev.github.io/swift/Array/",
        "teaser": null
      },{
        "title": "[Swift] Dictionary (사전)",
        "excerpt":"Dictionary란   사전은 순서가 지정되지 않은 키와 값으로 구성된 쌍의 모음이다   키는 중복되지 않고 고유하지만 각기 다른 키는 같은 값을 가리킬 수 있다.   모든 키는 같은 Type이어야 하고, 모든 값도 같은 Type이어야 한다.      키와 값은 서로 같은 Type일 필요는 없다 !       좌측의 Key는 모두 String type, 우측의 값은 모두 Int Type   key들은 모두 서로 다른 값이지만 Anna, Brian이 가지는 값을 보면 알 수 있듯이 값은 같을 수 있다.   Array와의 차이점?   Array는 인덱스로만 값에 접근할 수 있으며, 해당 인덱스는 정수여야만 한다. 또한 Array에서 모든 인덱스는 순차적이다.   반면에 Dictionary에서 Key를 가지고 값에 접근할 수 있으며, Key는 정수를 포함한 모든 Type이 될 수 있다. 특정한 순서가 없다.      모든 Type이 Key가 가능하다고 하지만 조건이 있다. 바로 Key로 사용할 Type이 Hashable 프로토콜을 따라야 한다는 것인데, 기본적으로 Int, String, Double같은 기본 타입은 해당 프로토콜을 이미 따르고 있지만 내가 정의한 Type의 경우 Hashable 프로토콜을 채택해야한다. 추후 Protocol 정리에서 해당내용을 다룰 수 있을 것 같다!    Dictionary 생성   리터럴 사용   대괄호로 묶인 쉼표로 구분된 키 - 값 쌍의 목록을 사용한다.   역시나 말은 어려우니 코드로 보자!   var namesAndScores = [\"Anna\" : 2, \"Brian\": 2, \"Craig\": 8, \"Donna\" : 6 ]   이 코드에서 Key의 Type은 String, Value의 Type은 Int이고 따라서,   namesAndScores의 Type은 [String: Int] 이다.   빈 Dictionary   var pairs: [String: Int] = [:] // 타입 추론이  var pairs2 = [String: Int]()   컴파일러는 빈 Dictionary 리터럴에서 유형추론을 할수 없으므로 Type을 명시하여 사용하거나   2번째 라인 처럼 이니셜라이저로 생성해줘야 한다 !   값 접근   Key 접근   Array와 유사한데 Array에서는 인덱스를 사용하지만 Dictionary에서는 Key로 접근한다   var namesAndScores = [\"Anna\" : 2, \"Brian\": 2, \"Craig\": 8, \"Donna\" : 6 ] print(\"Anna Score : \\(namesAndScores[\"Anna\"]!)\") // output &gt;&gt; 2   Key로 접근할 때 Key에 대한 값이 있는지 확인을 하고 없으면 nil을 반환해야하기 때문에 반환 Type은 옵셔널이다.   var namesAndScores = [\"Anna\" : 2, \"Brian\": 2, \"Craig\": 8, \"Donna\" : 6 ] namesAndScores[\"jisoo\"] // nil   Property &amp; Method   Array와 Dictionary는 Collection Protocol을 따릅니다      Protocol은 추후에 다시 학습해봅시다.    이 Collection 프로토콜을 따르기 떄문에 많은 프로퍼티와 메소드를 공유합니다.   자주 사용하는 isEmpty, count 또한 이 Collection 프로토콜에서 제공하는 프로퍼티입니다.   var namesAndScores = [\"Anna\" : 2, \"Brian\": 2, \"Craig\": 8, \"Donna\" : 6 ] namesAndScores.isEmpty // 텅 비어있는가? -&gt; false namesAndScores.count // Key - Value가 몇 쌍 있어? -&gt; 4   Dictionary 수정   사전을 만들고 그 사전에 접근하여 값을 가져오는 것까지 해봤습니다. 그렇다면 수정을 하는 것은 어떨까요?   var namesAndScores = [\"Anna\" : 2, \"Brian\": 2, \"Craig\": 8, \"Donna\" : 6 ] // sweetfood의 Key가 있다면 해당 값을 5로 수정, 없다면 5로 !  namesAndScores[\"sweetfood\"] = 5  //위와 동일한 코드 namesAndScores.updateValue(3, forKey:\"sweetfood\")   첨자에 Key를 사용하여 값을 넣어도 되고 마지막 줄 처럼 메소드를 사용하여 값을 넣어도 된다.   결과는 같지만 다른 점이 하나 있다. 첨자를 사용하는 경우에 원래 해당 Key에 값이 있었다면 그냥 덮어쓰기처럼 5로 변경이 되지만 마지막줄과 같이 메소드를 사용하면 기존에 있던 값을 옵셔널로 감싸서 반환하고 3으로 변경이 된다   namesAndScores[\"sweetfood\"] = 5 let returnValue = namesAndScores.updateValue(3, forKey:\"sweetfood\") // returnValue = 5, namesAndScores[\"sweetfood\"] = 3   만약 이전 값이 없다면? 반환 값이 옵셔널 타입이기 떄문에 nil이 반환된다!   var mDic = [String: Int]() let returnValue = mDic.updateValue(3, forKey: \"sweetfood\") // returnValue = nil, mDic[\"sweetfood\"] = 3   Dictionary 삭제   수정과 마찬가지로 첨자를 사용한 방법, 메소드를 사용한 방법이 있다 !   값 접근 예시에서 설명할 때 Key에 대한 값이 없으면 nil을 반환한다고 했었다!. 첨자를 사용할 땐 해당 Key값에  nil을 넣어주면 된다!   메소드를 사용할땐 removeValue(forKey:) 메소드를 사용한다!   namesAndScores[\"sweetfood\"] = nil namesAndScores.removeValue(forKey: \"sweetfood\")   removeValue함수를 사용하여 삭제를 할 경우 삭제한 값이 반환된다.      주의해야할 점이 하나 있다. 만약 Dictionary의 타입이 [String: Int?] 처럼 옵셔널 타입을 값으로 사용할 때 첨자를 사용하여 삭제를 하려고 namesAndScores[“sweetfood”] = nil 을 사용한다면 이는 키까지 완전히 제거하기 때문에 키를 유지하고 값만 nil로 변경하길 바란다면 updateValue메소드를 사용해야한다.    Dictionary 순회   Array처럼 for문을 사용하여 순회할 수 있다. Dictionary의 Elements는 키 - 값 쌍으로 이루어 지기 때문에 튜플을 사용한다.   for (name, score) in namesAndScores {     print(\"name: \\(name) score: \\(score)\") }   만약 Key나 Value 하나에 대해서만 순회를 하고 싶다면 keys, values를 통해 단일 항목에대해서 순회도 가능하다   // Key만 순회 for key in namesAndScores.keys {     print(\"key \\(key)\") } // Value만 순회 for value in namesAndScores.values{     print(\"value \\(value)\") }  ","categories": ["Swift"],
        "tags": ["Collection"],
        "url": "https://sweetfood-dev.github.io/swift/Dictionary/",
        "teaser": null
      },{
        "title": "[Swift] Function",
        "excerpt":"함수란?   특정 작업을 수행하는 코드 덩어리이다   이 덩어리에 이름을 부여하고 추후 특정작업을 수행할 때 이 부여한 이름을 사용해 함수를 호출할 수 있다   함수의 정의와 호출   정의   함수의 입력으로 사용되는 파라미터(혹 매개변수)를 하나 이상 정의하거나 정의하지 않을 수 있고 함수가 완료되었을 때 다시 전달할 값도 정의할 수 있다.   // func : 함수를 정의할 때 사용하는 Keyword // funcName :  함수의 이름  // (parameter: String) : 파라미터의 이름과 그 Type으로 함수의 입력 값  // -&gt; Int : 함수 실행 완료 후 반활할 값의 Type func funcName(parameter: String) -&gt; Int { }  ","categories": ["Swift"],
        "tags": ["Function"],
        "url": "https://sweetfood-dev.github.io/swift/Function/",
        "teaser": null
      },{
        "title": "[Swift] Function(2) Parameter와 Retrun",
        "excerpt":"Parameter 와 Returns   Parameter가 없는 함수   파라미터는 기본적으로 함수의 이름 뒤에 오는 () 사이에 정의해주는데 파라미터가 없는경우 그냥 ()만 작성한다   func noParameter()   Parameter가 있는 함수   1개 혹은 그 이상의 파라미터도 정의 가능하다.   ()안에 파라미터이름 : Type 으로 정의하며 1개 이상일 때는 , 로 구분을 해준다   func oneParameter(param1: Int) func twoParameter(param1: Int, param2: String) func threeParameter(param1: Int, param2: String, param3: [Double])   Return이 없는 함수   Return 값이 있는 경우 파라미터 정의 끝에 → Type 으로 작성을 해준다. 다만 Return 값이 없을 경우   → Type은 생략 해주면 된다!      Return의 Type에는 모든 타입이 들어갈 수 있으며 옵셔널 또한 가능하다!    func noReturnFunc()      엄밀히 말하자면 Return값이 있다 바로 → Void 인데 Void는 () Type의 빈 튜플이다    func noReturnFunc() // 이 함수는 엄밀히 말하자면 func noReturnFunc() -&gt; Void  // 요 함수이다.    Return이 있는 함수   Return이 1개만 있을 경우   func returnOneFunc(parameter: Int) -&gt; Int { \treturn parameter }   위 처럼 → Type을 뒤에 붙여 주며 함수 내부에서는 해당 Type의 값이나 변수를 return 해주어야 한다.   단일 표현식에서의 Return   위의 예제처럼 단일 표현식의 경우에는 return의 생략이 가능하며 추후 학습할 프로퍼티 getter에서도 이런 문법은 동일하게 적용 된다   func returnPlusThree(parameter: Int) -&gt; Int {     parameter + 3 // return 생략 가능 }   여러 Return값이 있는 함수   앞서 학습한 튜플을 사용하면 된다!   func returnTwoValue(array: [Int]) -&gt; (min : Int, max: Int) {     let minValue = array.min()! // 옵셔널 강제 해제     let maxValue = array.max()! // 옵셔널 강제 해제          return (minValue, maxValue) }  let result = returnTwoValue(array: [1,2,3,4,5]) result.max  result.min   이때 Return에 정의한 튜플은 앞서 학습한 튜플의 기능을 모두 사용할 수 있다.   이 코드에서는 min,max라는 별칭을 정해줬으며 함수의 return을 받은 result 상수에서 해당 별칭을 사용하였다.   함수의 인수 레이블과 파라미터(매개변수) 이름   모든 함수에는 인수 레이블과 파라미터 이름이 있다.   인수 레이블은 함수를 호출할 때 사용하고 파라미터 이름은 함수 내부에서 사용한다   만약 인수 레이블을 따로 작성하지 않으면 인수레이블은 파라미터 이름과 같다   func myFunction(value: Int) // value는 인수 레이블이자 파라미터 이름!   인수 레이블   인수레이블 작성은 파라미터 이름 앞에 공간을 두고 작성한다   func myFunction(label parameter: Int){ // 인수레이블은 label, 파라미터 이름은 parameter     let plusOne = parameter + 1 // 함수 내부에서는 파라미터 이름을 사용 }  myFunction(label: 3) // 함수 호출시에는 인수 레이블을 사용   위의 코드에서 볼 수 있듯 인수 레이블은 함수 호출 시 사용하고 파라미터 이름은 함수의 내부에서 사용한다   이러한 레이블은 적절히 사용한다면 영어 문장처럼 표현할 수 있어 가독성이 좋아지는 장점이 있다.   func greet(person: String, from hometown: String) -&gt; String {     // 단일 표현식으로 return 생략     \"Hello \\(person)! Glad you could visit from \\(hometown) }  print(greet(person:\"jisoo\", from: \"home\"))   인수레이블의 생략   print()처럼 인수가 없는 함수는 인수 레이블 위치에 _ 를 사용하여 만든다   func emptyLabel(_ text: String) {     print(text) }  emptyLabel(\"인수레이블 없이 사용할 수 있어요\")    파라미터(매개변수)   기본값   파라미터 정의 다음에 값을 할당하여 기본값을 사용할 수 있다.   기본값을 설정하면 함수 호출 시 기본값이 설정되어 있는 인자 레이블은 생략이 가능하다.   생략을 하게 되면 함수 내부에서 파라미터를 사용할 때 기본값이 적용된다   func defaultValue(num value: Int = 10) {     print(value) }  defaultValue() // 10 defaultValue(num: 20) // 20      파라미터의 Type은 유형 추론이 안된다!    가변 파라미터   가변파라미터를 사용하면 0개 이상의 값을 사용할 수 있다.   파라미터 Type뒤에 …를 붙여 선언한다.   가변 파라미터로 전달된 값은 함수 내에서 Array로 사용이 가능하다.   하지만 함수 호출 시에는 인자레이블의 Type으로 호출을 해야한다   func variadicParameter(num numbers: Int...) -&gt; Int{     let result = numbers.reduce(0, +) // 배열의 모든 요소를 더해줌     return result }  variadicParameter(num: 1,2,3,4,5,6) // 21 variadicParameter(num: [1,2,3,4,5,6]) // Int Type이 아닌 Array Type 으로 컴파일 에러   Swift Version에 따른 변경점   Swift 5.4   5.4 버전 이후 부터 가변 파라미터를 한개 이상 사용할 수 있다!   이전 버전에서는 2개 이상 사용 시     Only a single variadic parameter ‘…’ is permitted    오류가 발생하였는데   5.4 이후 부터 인수 레이블만 달려 있다면 1개 이상의 가변 파라미터를 사용할 수 있다!   func foo(_ a:Int, b: Double...) {} // Swift 5.4 이전 오류 foor(1, 2, 3, 4, 5, b: 1.0, 2.0, 3.0) // Swift 5.4 이후 사용 가능    ","categories": ["Swift"],
        "tags": ["Function"],
        "url": "https://sweetfood-dev.github.io/swift/Function2-ParameterAndReturn/",
        "teaser": null
      },{
        "title": "[Swift] Function(3) in-out",
        "excerpt":"In-Out   함수의 파라미터는 let으로 정의된 상수와 같다.   따라서 함수안에서 파라미터의 값을 변경하려 하면 컴파일 에러가 발생한다.   func increseAndPrint(_ param: Int) {     param += 1 // 컴파일 에러     print(param) }  var value = 5 increseAndPrint(value)   이해를 돕기 위해 위의 코드를 풀어보면   var value = 5 let param = value // == increseAndPrint(value) // 함수의 본문  param += 1 print(param)   이렇게 보면 에러가 나는 것이 당연한 것 처럼 보인다.   Swift에서 함수에 값을 전달할 때 변수 자체를 전달하는 것이 아니라 변수의 값을 파라미터에 복사한다   이런 방식을 값에 의한 전달, pass by value라고 한다. 그럼 어떻게 파라미터로 들어온 변수의 값을 변경할 수 있을까?   설명을 쉽게하기 위해 위 코드에서 함수 호출시 사용한 변수 value를 인수, 해당 인수의 값을 함수 내부에서 사용하는 param을 파라미터로 정의하겠다.   함수가 실행되고 끝날 때 파라미터의 값을 인수에 재차 복사를 해주면 된다. 이를 copy-in copy-out 이라 한다.      그래서 이름이 inout일지도???    단계를 다시 설명하면      함수가 호출되면 인수(value)값이 파라미터(param)에 복사된다.   함수 본문에서 파라미터(param)값이 수정이 된다.   함수가 종료 혹은 반환되면 파라미터(param)값이 인수(value)에 할당된다.   inout 키워드는 파라미터가 이렇게 인수에 다시 복사되어야함을 알려준다.   func increseAndPrint(_ param: inout Int) { // inout은 파라미터의 Type 앞에 선언     param += 1 // 컴파일 에러     print(\"param is \\(param)\") }  var value = 5 increseAndPrint(&amp;value) // &amp;은 뭐지? print(\"value is \\(value)\")   함수 호출에서도 다른점이 보이는데 inout 으로 선언된 파라미터에 전달된 인수에는 &amp;을 붙여 전달해야 한다.      내 생각인데 c언어의 포인터와 같은 개념으로 복사를 하기위해 해당 인수의 주소값을 받는 거란 생각이 든다.    실행해 보면 모두 6이 출력되는걸 확인할 수 있다!   유의할 점은 기본값이 있는 파라미터와 가변 파라미터에는 inout으로 정의할 수 없다.  ","categories": ["Swift"],
        "tags": ["Function"],
        "url": "https://sweetfood-dev.github.io/swift/function3-inout/",
        "teaser": null
      },{
        "title": "[Swift] Function(4) 함수 타입(Function Type)",
        "excerpt":"함수 타입   Swift에서는 함수를 Int, String과 같은 다른 타입들 처럼 변수 / 상수에 할당할 수 있다.   이 말은 함수를 하나의 타입으로 사용할 수 있다라는 것이다.   var intType: Int var stringType: String var funcType: func // ???????????   그렇다면 함수 타입은 어떻게 선언을 해줘야 하나..?   함수의 타입은 인자레이블의 타입, 반환값의 타입을 구성하여 나타낸다. 코드로 보면 이해가 더 빠르니 코드로 봐보자!   // type : (Int, String) -&gt; Void func foo(_ num: Int, from address: String) { } // type : (Int, String) -&gt; [Int] func foo2(num val: Int, at home: String) -&gt; [Int] { } // type : (Double, [Int]) -&gt; Bool func foo3(_ param1: Double, _ param2: [Int]) -&gt; Bool { }   주석으로 보면 알 수 있듯 함수의 이름과 인자레이블, 파라미터 이름을 다 생략하고 타입만 나열해준 것이   바로 함수의 타입이다   모든 타입은 변수 혹은 상수로 사용이 가능하기 때문에 함수 역시 변수 / 상수에 할당이 가능한 것이다.   그렇다면 어떻게 사용할까? 변수 / 상수에 할당을 했다면은 레이블이 없는 함수처럼 사용이 가능하다.   // type : (Int, Int) -&gt; Int func addNumber(_ num1: Int, and num2: Int) -&gt; Int {     num1 + num2 // return 생략 가능 }  var mathFunction : (Int, Int) -&gt; Int = addNumber print(mathFunction(1, 2)) // 3 출력   여기서 함수의 타입을 미리 선언해 주었지만 타입 추론도 가능하여 생략이 가능하다.   함수의 타입만 같다면 다른 기능을 하는 함수(이름이 다른 함수)도 얼마든지 할당이 가능하다!   // type : (Int, Int) -&gt; Int func addNumber(_ num1: Int, and num2: Int) -&gt; Int {     num1 + num2 // return 생략 가능 } func minusNumber(num1: Int, and num2: Int) -&gt; Int {     num1 - num2 }  var mathFunction : (Int, Int) -&gt; Int = addNumber print(mathFunction(1, 2)) // 3 출력 mathFunction = minusNumber // 다른 함수 할당  print(mathFunction(2,1)) // 1 출력   타입이기 때문에 함수의 파라미터로도, 리턴 값에도 함수를 사용할 수 있다.   파라미터로서의 함수 타입   func foo(_ mathFunction: (Int, Int) -&gt; Int, num1: Int, num2: Int) {     let result = mathFunction(num1, num2)     print(result) }   리턴 타입으로서의 함수 타입   func stepBackward(_ value: Int) -&gt; Int {     value - 1 }  func stepForward(_ value: Int) -&gt; Int {     value + 1 }  // (Int) -&gt; Int 타입의 함수를 리턴 func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {      backward ? stepBackward : stepForward }  var current = 3 let function = chooseStepFunction(backward: current &gt; 0) while current != 0 {     print(\"current : \\(current)\")     current = function(current) }      Swift의 타입은 값(value)타입과 참조(Reference)타입으로 나뉘는데 함수와 클래스는 참조 타입이다. 그래서 그런지 함수를 변수에 할당하거나 반환값에 함수를 적용할 때 Xcode에서 만들어주는 자동완성 목록에 stepForward(_:)가 있는데 아마 이 함수의 이름에도 주소값이 들어가 있는듯 하다   ","categories": ["Swift"],
        "tags": ["Function"],
        "url": "https://sweetfood-dev.github.io/swift/function4-functiontype/",
        "teaser": null
      }]
