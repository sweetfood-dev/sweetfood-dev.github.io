<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://sweetfood-dev.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sweetfood-dev.github.io/" rel="alternate" type="text/html" /><updated>2021-02-05T10:26:47+09:00</updated><id>https://sweetfood-dev.github.io/feed.xml</id><title type="html">공부 그리고 기록</title><subtitle>Swift / Algorithm</subtitle><author><name>권지수</name><email>kjsii123@naver.com</email></author><entry><title type="html">as as? as!</title><link href="https://sweetfood-dev.github.io/swift/1-type-casting/" rel="alternate" type="text/html" title="as as? as!" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/1-type-casting</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/1-type-casting/">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;실행 시점&lt;/th&gt;
      &lt;th&gt;캐스팅 종류&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;as&lt;/td&gt;
      &lt;td&gt;컴파일러가 타입 변환의 성공을 보장&lt;/td&gt;
      &lt;td&gt;컴파일 타임&lt;/td&gt;
      &lt;td&gt;업 캐스팅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;as?&lt;/td&gt;
      &lt;td&gt;변환에 실패하는 경우 nil을 반환&lt;/td&gt;
      &lt;td&gt;런타임&lt;/td&gt;
      &lt;td&gt;다운 캐스팅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;as!&lt;/td&gt;
      &lt;td&gt;변환에 실패하는 경우 런타임에러 발생&lt;/td&gt;
      &lt;td&gt;런타임&lt;/td&gt;
      &lt;td&gt;다운 캐스팅&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">  설명 실행 시점 캐스팅 종류 as 컴파일러가 타입 변환의 성공을 보장 컴파일 타임 업 캐스팅 as? 변환에 실패하는 경우 nil을 반환 런타임 다운 캐스팅 as! 변환에 실패하는 경우 런타임에러 발생 런타임 다운 캐스팅</summary></entry><entry><title type="html">클래스와 구조체</title><link href="https://sweetfood-dev.github.io/swift/02-Class-Struct/" rel="alternate" type="text/html" title="클래스와 구조체" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/02-Class-Struct</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/02-Class-Struct/">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Class&lt;/th&gt;
      &lt;th&gt;Struct&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;레퍼런스 타입&lt;/td&gt;
      &lt;td&gt;밸류 타입&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;객체화시 힙영역에 저장되고 그 주소값은 스택 영역에 저장, ARC로 메모리 관리&lt;/td&gt;
      &lt;td&gt;스택 영역에 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;상속가능&lt;/td&gt;
      &lt;td&gt;상속 불가, Protocol은 사용가능하다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;대입 연산 시 레퍼런스 공유&lt;/td&gt;
      &lt;td&gt;대입 연산 시  값 복사&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">Class Struct 레퍼런스 타입 밸류 타입 객체화시 힙영역에 저장되고 그 주소값은 스택 영역에 저장, ARC로 메모리 관리 스택 영역에 저장 상속가능 상속 불가, Protocol은 사용가능하다 대입 연산 시 레퍼런스 공유 대입 연산 시 값 복사</summary></entry><entry><title type="html">GCD</title><link href="https://sweetfood-dev.github.io/ios/4-GCD/" rel="alternate" type="text/html" title="GCD" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/4-GCD</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/4-GCD/">&lt;p&gt;&lt;strong&gt;GCD란&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Apple에서 제공하는 멀티쓰레드 처리 API&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
DisPatchQueue가 GCD에 존재합니다&lt;br /&gt;
DisPatchQueue는 메인스레드 / 백그라운드 스레드에서 작업실행을 관리하는 객체입니다&lt;br /&gt;
순차적으로 실행하는 Main Queue와 동시에 실행하는 Global Queue를 포함하고 있습니다&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Main Queue
    &lt;ul&gt;
      &lt;li&gt;보통 UI관련된 처리를 담당하고 앱이 실행 되었을 때 자동으로 실행됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Gloabal Queue
    &lt;ul&gt;
      &lt;li&gt;백그라운드에서 동작하고&lt;/li&gt;
      &lt;li&gt;동시에 작업을 수행합니다.&lt;/li&gt;
      &lt;li&gt;메인큐 작업에 영향을 주면 안되는 작업을 처리할 때 사용하며&lt;/li&gt;
      &lt;li&gt;QoS를 통해 작업의 우선순위를 부여할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">GCD란 Apple에서 제공하는 멀티쓰레드 처리 API</summary></entry><entry><title type="html">ViewController 생명 주기</title><link href="https://sweetfood-dev.github.io/ios/3-ViewController-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/" rel="alternate" type="text/html" title="ViewController 생명 주기" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/3-ViewController-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/3-ViewController-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/">&lt;p&gt;iOS에서는 화면전환을 할 때 기존의 화면 위에 새로운 화면을 쌓는 식으로 화면 전환을 합니다.&lt;br /&gt;
이 때 각각의 ViewController는 자신만의 생명주기를 가지고 있습니다&lt;br /&gt;
그래서 상황에 맞는 함수들이 호출 되는데 이 생명주기를 나타내는 대표적인 메소드들은 다음과 같습니다&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;ViewDidLoad
    &lt;ul&gt;
      &lt;li&gt;ViewController 클래스가 생성될 때 딱 한번 실행됩니다.&lt;/li&gt;
      &lt;li&gt;보통 초기화 작업이 이루어집니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ViewWillAppear
    &lt;ul&gt;
      &lt;li&gt;화면에 나타나기 직전에 실행됩니다&lt;/li&gt;
      &lt;li&gt;ViewDidload와 다르게 나타나기 직전마다 항상 실행됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ViewDidAppear
    &lt;ul&gt;
      &lt;li&gt;화면에 나타난 직후에 실행됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ViewWillDisAppear
    &lt;ul&gt;
      &lt;li&gt;화면에서 사라기지 직전에 실행됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ViewDidDisAppear
    &lt;ul&gt;
      &lt;li&gt;화면에서  사라지고 난 직후에 실행됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">iOS에서는 화면전환을 할 때 기존의 화면 위에 새로운 화면을 쌓는 식으로 화면 전환을 합니다. 이 때 각각의 ViewController는 자신만의 생명주기를 가지고 있습니다 그래서 상황에 맞는 함수들이 호출 되는데 이 생명주기를 나타내는 대표적인 메소드들은 다음과 같습니다 ViewDidLoad ViewController 클래스가 생성될 때 딱 한번 실행됩니다. 보통 초기화 작업이 이루어집니다 ViewWillAppear 화면에 나타나기 직전에 실행됩니다 ViewDidload와 다르게 나타나기 직전마다 항상 실행됩니다 ViewDidAppear 화면에 나타난 직후에 실행됩니다. ViewWillDisAppear 화면에서 사라기지 직전에 실행됩니다 ViewDidDisAppear 화면에서 사라지고 난 직후에 실행됩니다</summary></entry><entry><title type="html">Application 생명 주기</title><link href="https://sweetfood-dev.github.io/ios/3-App-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/" rel="alternate" type="text/html" title="Application 생명 주기" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/3-App-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/3-App-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/">&lt;p&gt;&lt;strong&gt;App 생명주기란&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;앱의 실행부터 종료까지의 주기를 말하며, 앱이 foreground나 background에 있을 때 시스템 알림에 응답하고 기타 중요한 시스템 관련 이벤트를 처리하는 단계들을 말한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앱 실행시 &lt;br /&gt;
UIAppliation 객체를 생성한다.&lt;br /&gt;
이후 UIApplication 어노테이션이 있는 객체를 찾아 AppDelegate를 생성한다.&lt;br /&gt;
Main Run Loop ( Main Event Loop)를 실행하고&lt;br /&gt;
Main Run Loop는 발생한 이벤트를 큐에 담아놓고&lt;br /&gt;
담겨 있는 이벤트를 꺼내 하나하나 실행하여 처리한다&lt;br /&gt;
AppDelegate 객체는 Life Cycle을 전달 받기 때문에 이를 통하여 현재 상태를 알 수 있다&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Life Cycle&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Not Running
    &lt;ul&gt;
      &lt;li&gt;아무 것도 하지 않는 상태 혹은, 실행 중이나 시스템에 의해 종료된 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;In-Active
    &lt;ul&gt;
      &lt;li&gt;상태 전환 과정에서 잠시 머무르는 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Active
    &lt;ul&gt;
      &lt;li&gt;실제 앱이 실행 되는 상태( 이벤트를 받는 단계 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BackGround
    &lt;ul&gt;
      &lt;li&gt;Suspend 진입 전에 거치는 단계&lt;/li&gt;
      &lt;li&gt;데이터의 저장등의 작업을 처리한다&lt;/li&gt;
      &lt;li&gt;일반적인 앱은 잠시 머물고 바로 Suspend상태로 진입하지만&lt;/li&gt;
      &lt;li&gt;음악, 통화, 녹음등의 앱은 이 상태에서도 동작한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Suspend
    &lt;ul&gt;
      &lt;li&gt;BackGround 상태지만 아무 실행도 하지 않는 상태, Not Running 상태와 같다&lt;/li&gt;
      &lt;li&gt;시스템이 임의로 BackGround상태를 Suspend로 만든다 ( 리소스 해제 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">App 생명주기란 앱의 실행부터 종료까지의 주기를 말하며, 앱이 foreground나 background에 있을 때 시스템 알림에 응답하고 기타 중요한 시스템 관련 이벤트를 처리하는 단계들을 말한다.</summary></entry><entry><title type="html">UICollectionViewDataSourcePrefetching</title><link href="https://sweetfood-dev.github.io/ios/2-UICollectionViewDataSourcePrefetching/" rel="alternate" type="text/html" title="UICollectionViewDataSourcePrefetching" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/2-UICollectionViewDataSourcePrefetching</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/2-UICollectionViewDataSourcePrefetching/">&lt;p&gt;UITableView/UICollectionView 에서 Pagenation을 위해 보통 아래 방법을 사용했다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        if indexPath.row == myItemList.count - 1 {
            fetchNextPage()
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
보여지는 Cell을 기준으로 List 의 마지막 아이템을 부르기 전에 다음 리스트 호출을 하는 식이다.&lt;br /&gt;
하지만 이번에 과제를 하면서 너무 버벅여 다른 방법을 찾아봤는데, UICollectionViewDataSourcePrefetching 프로토콜이 존재하였다&lt;br /&gt;
‘willDisplay’ 이 실제 보여지는 Cell을 기준으로 한다면 prefetchDataSource 는 이 작업을 백그라운드로 옮겨와 처리하는 것이다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension ViewController: UICollectionViewDataSourcePrefetching {
    func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {
		//내용 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 수정 후 눈에 띄게 속도가 향상되었다!!!&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">UITableView/UICollectionView 에서 Pagenation을 위해 보통 아래 방법을 사용했다.</summary></entry><entry><title type="html">CollectionViewLayout</title><link href="https://sweetfood-dev.github.io/ios/1-custom-layout/" rel="alternate" type="text/html" title="CollectionViewLayout" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/1-custom-layout</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/1-custom-layout/">&lt;p&gt;일반적인 collectionview의 delegate와 datasource는&lt;br /&gt;
화면에 셀을 표시하는 역할을 담당합니다&lt;br /&gt;
표시 할 때 구성과 같은 layout은 UICollectionViewLayout을 구현하여 처리해야합니다&lt;br /&gt;
&lt;br /&gt;
커스텀 CollectionViewLayout의 &lt;strong&gt;주 역할&lt;/strong&gt;은 UICollectionView에서 요청하는 레이아웃 관련 정보를 제공하는 것입니다.&lt;br /&gt;
레이아웃을 미리 준비해 놓았다가 UICollectionView에서 요청하면 준비한 레이아웃 정보를 제공합니다.&lt;br /&gt;
이 때 몇가지 필수 메소드들이 존재합니다&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;prepare()&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;UICollectionView에 표시되는 전체 크기를 계산하고 각 셀의 레이아웃 속성, collectionView의 크기와 cell의 위치를 미리 계산(캐싱)하여 메모리에 적재한 뒤 유지합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;collectionViewContentSize&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;collectionView의 전체 높이와 너비를 반환합니다.&lt;/li&gt;
      &lt;li&gt;화면에 보이는 contents 뿐만 아니라 collectionView의 전체를 반환해야 합니다.&lt;/li&gt;
      &lt;li&gt;collectionView는 이 정보를 활용하여 내부적으로 scrollView의 크기를 구성합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;layoutAttributesForElements (in :)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;in의 범위 안에 있는 모든 셀들의 레이아웃 속성들을 배열에 담아 반환합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;layoutAttributesForItem (at :)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;at으로 들어온 cell의 레이아웃 속성을 반환합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;호출 순서&lt;/strong&gt;&lt;br /&gt;
Layout prepare() : 전체 크기, 셀의 위치를 미리 계산&lt;br /&gt;
collectionView numberOfItemsInSection : 아이템의 전체 개수&lt;br /&gt;
Layout collectionViewContentSize : collectionView의 전체 크기(너비, 높이)&lt;br /&gt;
Layout layoutAttributesForElements : 범위 안에 있는 모든 셀들의 레이아웃 속성&lt;br /&gt;
Layout collectionViewContentSize :  collectionView의 전체 크기(너비, 높이)&lt;br /&gt;
collectionView cellForItemAt : cell 표시&lt;br /&gt;&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">일반적인 collectionview의 delegate와 datasource는 화면에 셀을 표시하는 역할을 담당합니다 표시 할 때 구성과 같은 layout은 UICollectionViewLayout을 구현하여 처리해야합니다 커스텀 CollectionViewLayout의 주 역할은 UICollectionView에서 요청하는 레이아웃 관련 정보를 제공하는 것입니다. 레이아웃을 미리 준비해 놓았다가 UICollectionView에서 요청하면 준비한 레이아웃 정보를 제공합니다. 이 때 몇가지 필수 메소드들이 존재합니다 prepare() UICollectionView에 표시되는 전체 크기를 계산하고 각 셀의 레이아웃 속성, collectionView의 크기와 cell의 위치를 미리 계산(캐싱)하여 메모리에 적재한 뒤 유지합니다. collectionViewContentSize collectionView의 전체 높이와 너비를 반환합니다. 화면에 보이는 contents 뿐만 아니라 collectionView의 전체를 반환해야 합니다. collectionView는 이 정보를 활용하여 내부적으로 scrollView의 크기를 구성합니다. layoutAttributesForElements (in :) in의 범위 안에 있는 모든 셀들의 레이아웃 속성들을 배열에 담아 반환합니다 layoutAttributesForItem (at :) at으로 들어온 cell의 레이아웃 속성을 반환합니다.</summary></entry><entry><title type="html">Lazy</title><link href="https://sweetfood-dev.github.io/swift/5-Lazy/" rel="alternate" type="text/html" title="Lazy" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/5-Lazy</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/5-Lazy/">&lt;p&gt;&lt;strong&gt;Lazy란&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;처음 사용되기전까지 연산이 되지 않습니다.&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;고려 사항&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;항상 var 키워드와 함께 사용
    &lt;ul&gt;
      &lt;li&gt;처음에는 아무 값이 없고 추후 사용될 때 값이 할당되기 때문에 let은 사용할 수 없습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구조체, 클래스에서 사용 가능&lt;/li&gt;
  &lt;li&gt;연산 프로퍼티에는 사용 불가
    &lt;ul&gt;
      &lt;li&gt;처음 사용 될 때, 메모리에 값을 올리고 이후에 사용 될 때는 메모리에 올린 값을 사용하기 때문에&lt;br /&gt;
사용할 때마다 연산이 되는 연산프로퍼티에서는 사용할 수 없습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클로저에서의 사용
    &lt;ul&gt;
      &lt;li&gt;클로저의 결과값으로 사용 될 때는 실행 이후 종료되기 때문에 메모리 누수의 걱정이 없지만&lt;/li&gt;
      &lt;li&gt;클로저 자체를 사용할 때는 클로저 리스트를 사용해 메모리 누수 방지를 해줘야 합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">Lazy란 처음 사용되기전까지 연산이 되지 않습니다.</summary></entry><entry><title type="html">오토레이아웃의 우선순위</title><link href="https://sweetfood-dev.github.io/swift/4-autolayout-priority/" rel="alternate" type="text/html" title="오토레이아웃의 우선순위" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/4-autolayout-priority</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/4-autolayout-priority/">&lt;p&gt;&lt;strong&gt;constraint&lt;/strong&gt;의 priority&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;제약 사항간의 우선순위&lt;/li&gt;
  &lt;li&gt;뷰들의 크기가 유동적으로 변할 때, 제약들간에 충돌이 발생할 수 있다&lt;/li&gt;
  &lt;li&gt;이 때 우선순위를 결정함으로 충돌을 해결할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">constraint의 priority 제약 사항간의 우선순위 뷰들의 크기가 유동적으로 변할 때, 제약들간에 충돌이 발생할 수 있다 이 때 우선순위를 결정함으로 충돌을 해결할 수 있다.</summary></entry><entry><title type="html">Frame과 Bounds</title><link href="https://sweetfood-dev.github.io/swift/3-frame-bounds/" rel="alternate" type="text/html" title="Frame과 Bounds" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/3-frame-bounds</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/3-frame-bounds/">&lt;p&gt;&lt;strong&gt;Frame&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;상위뷰 좌표 시스템 내에서 View의 위치와 크기&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Bounds&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자기 자신의 좌표시스템에서의 (sub view들의)위치와 크기, 부모뷰와는 관계가 없다&lt;/li&gt;
  &lt;li&gt;default origin은 0,0이다&lt;/li&gt;
  &lt;li&gt;origin의 변경은 sub view들의 위치가 변경됨을 의미&lt;/li&gt;
  &lt;li&gt;sub view의 위치가 변한다는 것은 그려져야하는 위치가 달라지는 것이지 sub view들의 frame 값의 변화는 없다&lt;/li&gt;
  &lt;li&gt;스크롤 시 sub view들의 위치가 달라지는 것이 대표적인 예이다&lt;/li&gt;
&lt;/ul&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">Frame 상위뷰 좌표 시스템 내에서 View의 위치와 크기</summary></entry></feed>