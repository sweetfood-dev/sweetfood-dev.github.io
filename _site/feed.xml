<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://sweetfood-dev.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sweetfood-dev.github.io/" rel="alternate" type="text/html" /><updated>2021-07-20T23:34:50+09:00</updated><id>https://sweetfood-dev.github.io/feed.xml</id><title type="html">공부 그리고 기록</title><subtitle>Swift / Algorithm</subtitle><author><name>권지수</name><email>kjsii123@naver.com</email></author><entry><title type="html">옵셔널의 사용</title><link href="https://sweetfood-dev.github.io/Optional2/" rel="alternate" type="text/html" title="옵셔널의 사용" /><published>2021-07-20T00:00:00+09:00</published><updated>2021-07-20T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/Optional2</id><content type="html" xml:base="https://sweetfood-dev.github.io/Optional2/">&lt;p&gt;이전글 &lt;a href=&quot;https://sweetfood-dev.github.io/Optional/&quot;&gt;Optional&lt;/a&gt;에서는 Optional과 nil에 대해 알아 보았다&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;옵셔널을 사용하기 위해 아래와 같은 코드를 실행해보았다&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/optional.png&quot; alt=&quot;&quot; /&gt;
Swift는 Type에 대해 엄격하다. Int Type과 Int? Type은 엄연히 다른 타입이다.&lt;br /&gt;
Int type으로 선언된 변수에는 Int? type의 값이 들어 갈 수 없다. 그렇다면?&lt;br /&gt;
옵셔널을 &lt;strong&gt;해제&lt;/strong&gt; 해주어야 한다.  그렇다면 어떻게 해제를 하여 사용하는지 알아보자!!&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;if문과 강제 언래핑&lt;/strong&gt;&lt;br /&gt;
if 문을 사용하여 옵셔널과 nil을 비교하여 옵셔널에 값이 있는지, 아니면 없는지(nil)를 확인할 수 있다&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/Optional_if.png&quot; alt=&quot;&quot; /&gt;
if 문에서 nil 이 아닐 때 print가 실행이 된다. 그럼 print가 되었을때 옵셔널 변수의 값은 어떨까?&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/Optional_if2.png&quot; alt=&quot;&amp;lt;br&amp;gt;&quot; /&gt;
optional 변수인 &lt;strong&gt;convertedNumber&lt;/strong&gt;는 Optional(123)이 출력되고, 일반 Int 타입의 변수 intTypeNumber은 123이 출력된다.&lt;br /&gt;
Optional(123)에서 괄호 안에 있는 123을 꺼내 사용하고 싶다면?&lt;br /&gt; 변수명 이름뒤에 &lt;strong&gt;!&lt;/strong&gt; 만 붙이면 된다&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/Optional_if3.png&quot; alt=&quot;&quot; /&gt;
&lt;strong&gt;!&lt;/strong&gt; 를 붙여 Optionald 해제하는 것을 &lt;strong&gt;강제 언래핑&lt;/strong&gt; 이라고 한다. 이 강제 언래핑을 사용할 때에는 항상 nil인지를 확인 후에 사용해야한다. 만약 확인을 하지 않았을 때 변수가 nil인 상태라면 런타임 오류가 발생할 것이다!
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Optional Binding&lt;/strong&gt; &lt;br /&gt;
옵셔널을 해제 하는 또 다른 방법엔 옵셔널 바인딩이 있다.&lt;br /&gt;
옵셔널 바인딩을 사용하면 옵셔널에 값이 있는지 확인하고 값이 있다면&lt;strong&gt;해당 값&lt;/strong&gt;을  임시 상수나 변수로 &lt;strong&gt;추출&lt;/strong&gt;하여  사용할 수 있다&lt;br /&gt;
이 때, 추출된 값은 옵셔널이 해제된 순수한 값이므로 일반 변수처럼 사용 가능하다.&lt;br /&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Optional Binding의 형태
if (let 혹은 var) 추출 후 사용할 변수 = 옵셔널 변수 {
// 코드 실행
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;강제 언래핑에 사용한 예제 코드를 옵셔널 바인딩 형태로 변경 하면 다음과 같다&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let possibleNumber = &quot;123&quot;
if let actualNumber = Int(possibleNumber) {
print(&quot;문자열 \(possibleNumber)은 Int \(actualNumber) 이다!&quot;)
}else {
print(&quot;문자열 \(possibleNumber)는 Int로 변환할 수 없다&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Int(possibleNumber)가 반환하는 옵셔널 Int에 값이 있으면 해당 값을 &lt;strong&gt;추출&lt;/strong&gt;하여 actualNumber에 설정해라!&lt;br /&gt;
actualNumber에 값이 들어가 있다면 해당 if문 안에서는 일반 상수처럼(var로 선언하였다면 변수) 사용이 가능하다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><summary type="html">이전글 Optional에서는 Optional과 nil에 대해 알아 보았다</summary></entry><entry><title type="html">Optional</title><link href="https://sweetfood-dev.github.io/Optional/" rel="alternate" type="text/html" title="Optional" /><published>2021-07-19T00:00:00+09:00</published><updated>2021-07-19T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/Optional</id><content type="html" xml:base="https://sweetfood-dev.github.io/Optional/">&lt;p&gt;옵셔널이란? : 값이 없을 수 있는 상황에서 Optional을 사용한다. &lt;br /&gt;
&lt;br /&gt;
옵셔널로 사용할 Type뒤에 ?를 붙여 사용한다. &lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var number : Int? // Int 옵셔널 
var text : String? // String 옵셔널
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;값이 없을 수 있다는 것은 무슨 의미일까? &lt;br /&gt;
String  값을 Int로 변환을 해야하는 경우 아래처럼 사용할 수 있다.&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var test: Int = Int(&quot;123&quot;) // test = 123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 다음과 같은 경우엔?&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var test: Int = Int(&quot;Hello World&quot;) // test = ??
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;변환 할 수 없을 것이다. 이때 변환할 수 없음, 값이 없음이란 의미로 &lt;strong&gt;nil&lt;/strong&gt;이란 값을 반환할 것이다 &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// var test: Int = Int(&quot;Hello World&quot;) 
var test: Int? = Int(&quot;Hello World&quot;) // test = nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;주석 처리한 코드와 그 밑에 코드를 보면 ?가 달려 있는걸 알 수 있다 &lt;br /&gt;
이 물음표는 해당 타입이 옵셔널이라는 것을 나타낸다! &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;정리하자면 Optional은 변수 혹은 상수에 &lt;strong&gt;값이 없음&lt;/strong&gt;을 나타낼 수 있게 만들어 주고 값이 없는 상태는 &lt;strong&gt;nil&lt;/strong&gt;로 표현한다!&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 &lt;strong&gt;nil&lt;/strong&gt; 이란 놈은 이전 obj-c에서도 사용했었던 것 같은데 obj-c와 Swift에서의 nil은 같은 의미로 사용되는걸까? &lt;br /&gt;
기억에 obj-c에서는 따로 Optional이라는 개념이 없었던 것 같다.&lt;br /&gt;
&lt;br /&gt;
obj-c에서의 nil은 &lt;strong&gt;유효한 객체가 없음&lt;/strong&gt;의 의미로 쓰인다고 한다. &lt;br /&gt;
Swift에서의 nil은 &lt;strong&gt;값이 없음&lt;/strong&gt;을 의미한다는데 같은 뜻 아닌가? 라고 할 수 있지만 &lt;strong&gt;객체&lt;/strong&gt;와 &lt;strong&gt;값&lt;/strong&gt;은 아주 큰 차이다&lt;br /&gt;
obj-c에서의 nil을 좀 더 풀어 말하면 &lt;strong&gt;존재하지 않는 객체에 대한 포인터&lt;/strong&gt;라고 나와있다. &lt;br /&gt;
즉 obj-c 에서 nil은 객체 type에 대해서만 사용이 가능하다란 것이다. obj-c에서 &lt;strong&gt;일반 타입&lt;/strong&gt;에 대한 값 없음은 NSNotFound라는 특수 값을 반환하여 나타낸다고 한다!&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;obj-c와 Swift의 nil의 차이점을 정리하자면,&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Obj-c&lt;/th&gt;
      &lt;th&gt;Swift&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;의미&lt;/td&gt;
      &lt;td&gt;유효한 “객체”가 없음(포인터)&lt;/td&gt;
      &lt;td&gt;“값” 없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;사용 가능한 Type&lt;/td&gt;
      &lt;td&gt;객체&lt;/td&gt;
      &lt;td&gt;모든 유형 ( 객체, 구조체, 열거형등등)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><summary type="html">옵셔널이란? : 값이 없을 수 있는 상황에서 Optional을 사용한다. 옵셔널로 사용할 Type뒤에 ?를 붙여 사용한다. var number : Int? // Int 옵셔널 var text : String? // String 옵셔널</summary></entry><entry><title type="html">간편하게 포스트 하는 법?</title><link href="https://sweetfood-dev.github.io/GitBlog_Post/" rel="alternate" type="text/html" title="간편하게 포스트 하는 법?" /><published>2021-07-06T00:00:00+09:00</published><updated>2021-07-06T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/GitBlog_Post</id><content type="html" xml:base="https://sweetfood-dev.github.io/GitBlog_Post/">&lt;p&gt;터미널에서 로컬의 gitblog 폴더로 이동! &lt;br /&gt;
jekyll serve 실행 &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://localhost:4000/admin&quot;&gt;http://localhost:4000/admin&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;편하게 글 올리자!&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><summary type="html">터미널에서 로컬의 gitblog 폴더로 이동! jekyll serve 실행</summary></entry><entry><title type="html">MVC 패턴</title><link href="https://sweetfood-dev.github.io/ios/2-MVC/" rel="alternate" type="text/html" title="MVC 패턴" /><published>2021-02-10T00:00:00+09:00</published><updated>2021-02-10T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/2-MVC</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/2-MVC/">&lt;p&gt;Apple의 MVC를 학습하기전에 전통적인 MVC에 대해 알아보자!&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/Posts/iOS/tranditional_mvc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림을 보면 MVC가 모두 밀접하게 연관되어 있다&lt;br /&gt;
이는 곧 재사용성이 떨어짐을 의미한다&lt;br /&gt;
그만 알아보자&lt;br /&gt;
&lt;strong&gt;전통적인 MVC는 iOS에 적합해 보이지 않는다!&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Apple이 권고하는 MVC에 대해 알아보자.&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/images/Posts/iOS/cocoa_mvc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림에서 볼 수 있듯 Controller는 중간에서 Model과 View를 이어준다&lt;br /&gt;
Model – View는 서로 알 필요가 없다&lt;br /&gt;
Controller는 여전히 재사용이 어려워 보인다&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;한계&lt;/strong&gt;&lt;br /&gt;
위의 그림과 대조적이게 실제로 Cocoa MVC는 다음 그림과 같다&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/images/Posts/iOS/real_cocoa_mvc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왜 위와 같이 구성될까?&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Controller는 View를 가지고 있다.(그래서 이름도 ViewController다)&lt;/li&gt;
  &lt;li&gt;따라서 View의 생명 주기와 Controller의 분리가 사실상 어렵다&lt;/li&gt;
  &lt;li&gt;이렇게 View를 가지고 있고, 그 생명주기도 관리하기 때문에 Controller자체가 거대해진다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;좋은 아키텍쳐 특징에서 바라보기&lt;/strong&gt;&lt;br /&gt;
좋은 아키텍처의 특징, 요소 측면에서 이 패턴을 파악해보자!&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;책임 분리
    &lt;ul&gt;
      &lt;li&gt;View와 Controller의 관계가 매우 밀접하여 , 책임분리가 안된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트
    &lt;ul&gt;
      &lt;li&gt;View와 Controller의 밀접한 관계로 인해 사실상 Model만 테스트가 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용 용이성
    &lt;ul&gt;
      &lt;li&gt;코드길이는 적고, 진입장벽 자체는 낮다!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;정리&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;개발속도가 빠르기에 아키텍처에 투자할 시간이 부족할 때 사용하면 유용하다&lt;/li&gt;
  &lt;li&gt;유지보수 비용이 많이 들어가는 편이다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;MVC가 개발속도는 짱이다! 그러나 유지보수 비용은 많이 들어간다!&lt;/strong&gt;&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">Apple의 MVC를 학습하기전에 전통적인 MVC에 대해 알아보자!</summary></entry><entry><title type="html">아키텍처</title><link href="https://sweetfood-dev.github.io/ios/1-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/" rel="alternate" type="text/html" title="아키텍처" /><published>2021-02-10T00:00:00+09:00</published><updated>2021-02-10T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/1-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/1-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/">&lt;p&gt;&lt;strong&gt;왜 아키텍처를 사용해야하지?&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;개발을 하다보면 디버깅을 해야하는 상황이 필연적으로 찾아온다&lt;br /&gt;
이 때 프로젝트의 몸집이 크다면 디버깅을 하는데 있어 어려움을 겪게 될 것이다&lt;br /&gt;
구조적으로 잘 정의된 프로젝트는 디버깅을 쉽게 해주며, 개발자간의 의사소통, 유지보수에도 도움이 된다!&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;좋은 아키텍쳐의 특징
    &lt;ul&gt;
      &lt;li&gt;객체간 &lt;strong&gt;책임 분리&lt;/strong&gt;가 균형있게 잡혀 있고 명확하게 이루어저야 한다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;테스트&lt;/strong&gt;가 용이해야 한다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;사용이 용이&lt;/strong&gt;해야 한다. 즉 유지 보수가 쉬워야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;책임 분리는 왜 이루어 저야 할까?&lt;br /&gt;
로직을 쉽게, 단순하게 한눈에 볼 수 있다&lt;br /&gt;
즉, 복잡함을 극복하는 방법은 &lt;strong&gt;단일책임 원칙&lt;/strong&gt;으로 책임을 나누는 것이다!&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;왜 테스트가 가능해야 할까?&lt;br /&gt;
런타임 내에서 이슈를 찾는것을 도와준다&lt;br /&gt;
실사용자가 이슈를 접한다면 그 이슈를 수정하는데 오랜 시간이 걸리니까, 미연에 방지해야한다!&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;사용의 용이&lt;br /&gt;
단순하다. &lt;strong&gt;유지보수&lt;/strong&gt;가 용이하니까!&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;어떤 아키텍쳐들이 있는데?&lt;/strong&gt;&lt;br /&gt;
기본적으로 많이 접해본 mvc, mvp, mvvm, viper가 있고 이러한 아키텍쳐는 &lt;br /&gt;
3가지 카테고리(요소)를 포함한다&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;요소&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Model&lt;/td&gt;
      &lt;td&gt;데이터, 데이터 접근자&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;View&lt;/td&gt;
      &lt;td&gt;화면에 표시되는 UI적인 요소&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Controller,Presentor,ViewModel&lt;/td&gt;
      &lt;td&gt;model과 View를 붙여준다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;View의 액션을 처리하여 Model을 변경하거나&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Model이 변경되었을 때 View를 갱신하는 책임을 가진다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이러한 구성을 통해 이해가 용이, 재사용이 가능, 독립적으로 테스트가 가능한 이점을 얻을 수 있다!&lt;br /&gt;
다음 포스트를 통해 mvc 부터 차근차근 알아보자!&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">왜 아키텍처를 사용해야하지?</summary></entry><entry><title type="html">MVVM</title><link href="https://sweetfood-dev.github.io/ios/4-MVVM/" rel="alternate" type="text/html" title="MVVM" /><published>2021-02-10T00:00:00+09:00</published><updated>2021-02-10T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/4-MVVM</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/4-MVVM/">&lt;p&gt;MVVM 패턴은 MVP와 비슷하다&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/images/Posts/iOS/mvvm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ViewController를 MVP에선 &lt;strong&gt;PassiveView&lt;/strong&gt;로 보앗듯이 &lt;br /&gt;
&lt;strong&gt;MVVM&lt;/strong&gt;에서는 &lt;strong&gt;View&lt;/strong&gt;로 본다&lt;br /&gt;
View와 Model이 연결되지 않는다 &lt;br /&gt;
View와 ViewModel사이를 바인딩으로 연결해 준다&lt;br /&gt;
다만 구조자체가 복잡하기 때문에 디버깅이 비교적 오래 걸린다&lt;br /&gt;
&lt;br /&gt;
&lt;strong&gt;ViewModel이란?&lt;/strong&gt;&lt;br /&gt;
View의 독립된 표현 혹은 상태를 말한다&lt;br /&gt;
Model에서 변경을 호출하고 Model 자체를 갱신한다&lt;br /&gt;
View와 Model 사이에서 바인딩을 하여 갱신한다&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;좋은 아키텍쳐 특징에서 보기&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;책임분배 : MVVM에서의 View는 MVP의 View보다 책임지는 것이 더 많다&lt;/li&gt;
  &lt;li&gt;테스트 : ViewModel은 View에 대해 전혀 모르기 때문에 테스트가 용이하다&lt;/li&gt;
  &lt;li&gt;사용용이성 : MVP보다 비교적 적은 코드로 개발할 수 있다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;View 입장에서 바인딩을 하기 때문에 View를 갱신하는데 추가 코드가 필요하지 않다!&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;테스트에도 좋은 난이도 있는 아키텍처&lt;/strong&gt;&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">MVVM 패턴은 MVP와 비슷하다</summary></entry><entry><title type="html">MVP</title><link href="https://sweetfood-dev.github.io/ios/3-MVP/" rel="alternate" type="text/html" title="MVP" /><published>2021-02-10T00:00:00+09:00</published><updated>2021-02-10T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/3-MVP</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/3-MVP/">&lt;p&gt;MVC에 이어 MVP를 알아보자&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/images/Posts/iOS/mvp1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본적으로 MVC와 유사하다&lt;br /&gt;
차이점은 ViewController가 View와 함께 &lt;strong&gt;Passive View&lt;/strong&gt;에 속해있다는 점!&lt;br /&gt;
&lt;strong&gt;presenter&lt;/strong&gt;는 Model과 Passive View 사이에 다리 역할을 하며 &lt;br /&gt;
이로 인해 MVC에서의 문제였던 View의 생명 주기에서 자유로울 수 있다 &lt;br /&gt;
View는 이로 인해 데이터와 상태를 갱신하는 역할에 집중 할 수 있다&lt;br /&gt;
같은 이유로 View도 Test가 가능하게 되었다&lt;br /&gt;
다만 View의 갱신, 이벤트 처리에 대한 메소드 바인딩이 이루어저야 하여&lt;br /&gt;
개발비용이 MVC보다 더 많이 든다!&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;좋은 아키텍처 특징에서 보기&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;책임 분배 : Presenter와 Model을 완벽하게 분리하고 View는 단순히 출력하는 용도로 분리 되었다&lt;/li&gt;
  &lt;li&gt;테스트 : View의 재사용이 가능하여 대부분의 로직을 테스트할 수 있다&lt;/li&gt;
  &lt;li&gt;사용 용이성 : 코드는 MVC에 비해 늘어나지만 각 요소들의 역할이 더 명확해 진다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;iOS에서 테스트를 하기에 좋다!, 다만 코드는 길어진다!&lt;/strong&gt;&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">MVC에 이어 MVP를 알아보자</summary></entry><entry><title type="html">오토레이아웃의 우선순위</title><link href="https://sweetfood-dev.github.io/swift/4-autolayout-priority/" rel="alternate" type="text/html" title="오토레이아웃의 우선순위" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/4-autolayout-priority</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/4-autolayout-priority/">&lt;p&gt;&lt;strong&gt;constraint&lt;/strong&gt;의 priority&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;제약 사항간의 우선순위&lt;/li&gt;
  &lt;li&gt;뷰들의 크기가 유동적으로 변할 때, 제약들간에 충돌이 발생할 수 있다&lt;/li&gt;
  &lt;li&gt;이 때 우선순위를 결정함으로 충돌을 해결할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">constraint의 priority 제약 사항간의 우선순위 뷰들의 크기가 유동적으로 변할 때, 제약들간에 충돌이 발생할 수 있다 이 때 우선순위를 결정함으로 충돌을 해결할 수 있다.</summary></entry><entry><title type="html">Frame과 Bounds</title><link href="https://sweetfood-dev.github.io/swift/3-frame-bounds/" rel="alternate" type="text/html" title="Frame과 Bounds" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/3-frame-bounds</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/3-frame-bounds/">&lt;p&gt;&lt;strong&gt;Frame&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;상위뷰 좌표 시스템 내에서 View의 위치와 크기&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Bounds&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자기 자신의 좌표시스템에서의 (sub view들의)위치와 크기, 부모뷰와는 관계가 없다&lt;/li&gt;
  &lt;li&gt;default origin은 0,0이다&lt;/li&gt;
  &lt;li&gt;origin의 변경은 sub view들의 위치가 변경됨을 의미&lt;/li&gt;
  &lt;li&gt;sub view의 위치가 변한다는 것은 그려져야하는 위치가 달라지는 것이지 sub view들의 frame 값의 변화는 없다&lt;/li&gt;
  &lt;li&gt;스크롤 시 sub view들의 위치가 달라지는 것이 대표적인 예이다&lt;/li&gt;
&lt;/ul&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">Frame 상위뷰 좌표 시스템 내에서 View의 위치와 크기</summary></entry><entry><title type="html">as as? as!</title><link href="https://sweetfood-dev.github.io/swift/1-type-casting/" rel="alternate" type="text/html" title="as as? as!" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/1-type-casting</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/1-type-casting/">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;실행 시점&lt;/th&gt;
      &lt;th&gt;캐스팅 종류&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;as&lt;/td&gt;
      &lt;td&gt;컴파일러가 타입 변환의 성공을 보장&lt;/td&gt;
      &lt;td&gt;컴파일 타임&lt;/td&gt;
      &lt;td&gt;업 캐스팅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;as?&lt;/td&gt;
      &lt;td&gt;변환에 실패하는 경우 nil을 반환&lt;/td&gt;
      &lt;td&gt;런타임&lt;/td&gt;
      &lt;td&gt;다운 캐스팅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;as!&lt;/td&gt;
      &lt;td&gt;변환에 실패하는 경우 런타임에러 발생&lt;/td&gt;
      &lt;td&gt;런타임&lt;/td&gt;
      &lt;td&gt;다운 캐스팅&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">  설명 실행 시점 캐스팅 종류 as 컴파일러가 타입 변환의 성공을 보장 컴파일 타임 업 캐스팅 as? 변환에 실패하는 경우 nil을 반환 런타임 다운 캐스팅 as! 변환에 실패하는 경우 런타임에러 발생 런타임 다운 캐스팅</summary></entry></feed>