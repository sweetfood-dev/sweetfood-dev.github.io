<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://sweetfood-dev.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sweetfood-dev.github.io/" rel="alternate" type="text/html" /><updated>2021-02-05T08:59:05+09:00</updated><id>https://sweetfood-dev.github.io/feed.xml</id><title type="html">공부 그리고 기록</title><subtitle>Swift / Algorithm</subtitle><author><name>권지수</name><email>kjsii123@naver.com</email></author><entry><title type="html">Frame과 Bounds</title><link href="https://sweetfood-dev.github.io/swift/3-frame-bounds/" rel="alternate" type="text/html" title="Frame과 Bounds" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/3-frame-bounds</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/3-frame-bounds/">&lt;p&gt;&lt;strong&gt;Frame&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;상위뷰 좌표 시스템 내에서 View의 위치와 크기&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Bounds&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자기 자신의 좌표시스템에서의 (sub view들의)위치와 크기, 부모뷰와는 관계가 없다&lt;/li&gt;
  &lt;li&gt;default origin은 0,0이다&lt;/li&gt;
  &lt;li&gt;origin의 변경은 sub view들의 위치가 변경됨을 의미&lt;/li&gt;
  &lt;li&gt;sub view의 위치가 변한다는 것은 그려져야하는 위치가 달라지는 것이지 sub view들의 frame 값의 변화는 없다&lt;/li&gt;
  &lt;li&gt;스크롤 시 sub view들의 위치가 달라지는 것이 대표적인 예이다&lt;/li&gt;
&lt;/ul&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">Frame 상위뷰 좌표 시스템 내에서 View의 위치와 크기</summary></entry><entry><title type="html">as as? as!</title><link href="https://sweetfood-dev.github.io/swift/1-type-casting/" rel="alternate" type="text/html" title="as as? as!" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/1-type-casting</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/1-type-casting/">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;실행 시점&lt;/th&gt;
      &lt;th&gt;캐스팅 종류&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;as&lt;/td&gt;
      &lt;td&gt;컴파일러가 타입 변환의 성공을 보장&lt;/td&gt;
      &lt;td&gt;컴파일 타임&lt;/td&gt;
      &lt;td&gt;업 캐스팅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;as?&lt;/td&gt;
      &lt;td&gt;변환에 실패하는 경우 nil을 반환&lt;/td&gt;
      &lt;td&gt;런타임&lt;/td&gt;
      &lt;td&gt;다운 캐스팅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;as!&lt;/td&gt;
      &lt;td&gt;변환에 실패하는 경우 런타임에러 발생&lt;/td&gt;
      &lt;td&gt;런타임&lt;/td&gt;
      &lt;td&gt;다운 캐스팅&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">  설명 실행 시점 캐스팅 종류 as 컴파일러가 타입 변환의 성공을 보장 컴파일 타임 업 캐스팅 as? 변환에 실패하는 경우 nil을 반환 런타임 다운 캐스팅 as! 변환에 실패하는 경우 런타임에러 발생 런타임 다운 캐스팅</summary></entry><entry><title type="html">Application 생명 주기</title><link href="https://sweetfood-dev.github.io/ios/3-App-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/" rel="alternate" type="text/html" title="Application 생명 주기" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/3-App-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/3-App-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/">&lt;p&gt;&lt;strong&gt;App 생명주기란&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;앱의 실행부터 종료까지의 주기를 말하며, 앱이 foreground나 background에 있을 때 시스템 알림에 응답하고 기타 중요한 시스템 관련 이벤트를 처리하는 단계들을 말한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앱 실행시 &lt;br /&gt;
UIAppliation 객체를 생성한다.&lt;br /&gt;
이후 UIApplication 어노테이션이 있는 객체를 찾아 AppDelegate를 생성한다.&lt;br /&gt;
Main Run Loop ( Main Event Loop)를 실행하고&lt;br /&gt;
Main Run Loop는 발생한 이벤트를 큐에 담아놓고&lt;br /&gt;
담겨 있는 이벤트를 꺼내 하나하나 실행하여 처리한다&lt;br /&gt;
AppDelegate 객체는 Life Cycle을 전달 받기 때문에 이를 통하여 현재 상태를 알 수 있다&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Life Cycle&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Not Running
    &lt;ul&gt;
      &lt;li&gt;아무 것도 하지 않는 상태 혹은, 실행 중이나 시스템에 의해 종료된 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;In-Active
    &lt;ul&gt;
      &lt;li&gt;상태 전환 과정에서 잠시 머무르는 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Active
    &lt;ul&gt;
      &lt;li&gt;실제 앱이 실행 되는 상태( 이벤트를 받는 단계 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BackGround
    &lt;ul&gt;
      &lt;li&gt;Suspend 진입 전에 거치는 단계&lt;/li&gt;
      &lt;li&gt;데이터의 저장등의 작업을 처리한다&lt;/li&gt;
      &lt;li&gt;일반적인 앱은 잠시 머물고 바로 Suspend상태로 진입하지만&lt;/li&gt;
      &lt;li&gt;음악, 통화, 녹음등의 앱은 이 상태에서도 동작한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Suspend
    &lt;ul&gt;
      &lt;li&gt;BackGround 상태지만 아무 실행도 하지 않는 상태, Not Running 상태와 같다&lt;/li&gt;
      &lt;li&gt;시스템이 임의로 BackGround상태를 Suspend로 만든다 ( 리소스 해제 )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">App 생명주기란 앱의 실행부터 종료까지의 주기를 말하며, 앱이 foreground나 background에 있을 때 시스템 알림에 응답하고 기타 중요한 시스템 관련 이벤트를 처리하는 단계들을 말한다.</summary></entry><entry><title type="html">ViewController 생명 주기</title><link href="https://sweetfood-dev.github.io/ios/3-ViewController-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/" rel="alternate" type="text/html" title="ViewController 생명 주기" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/3-ViewController-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/3-ViewController-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/">&lt;p&gt;iOS에서는 화면전환을 할 때 기존의 화면 위에 새로운 화면을 쌓는 식으로 화면 전환을 합니다.&lt;br /&gt;
이 때 각각의 ViewController는 자신만의 생명주기를 가지고 있습니다&lt;br /&gt;
그래서 상황에 맞는 함수들이 호출 되는데 이 생명주기를 나타내는 대표적인 메소드들은 다음과 같습니다&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;ViewDidLoad
    &lt;ul&gt;
      &lt;li&gt;ViewController 클래스가 생성될 때 딱 한번 실행됩니다.&lt;/li&gt;
      &lt;li&gt;보통 초기화 작업이 이루어집니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ViewWillAppear
    &lt;ul&gt;
      &lt;li&gt;화면에 나타나기 직전에 실행됩니다&lt;/li&gt;
      &lt;li&gt;ViewDidload와 다르게 나타나기 직전마다 항상 실행됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ViewDidAppear
    &lt;ul&gt;
      &lt;li&gt;화면에 나타난 직후에 실행됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ViewWillDisAppear
    &lt;ul&gt;
      &lt;li&gt;화면에서 사라기지 직전에 실행됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ViewDidDisAppear
    &lt;ul&gt;
      &lt;li&gt;화면에서  사라지고 난 직후에 실행됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">iOS에서는 화면전환을 할 때 기존의 화면 위에 새로운 화면을 쌓는 식으로 화면 전환을 합니다. 이 때 각각의 ViewController는 자신만의 생명주기를 가지고 있습니다 그래서 상황에 맞는 함수들이 호출 되는데 이 생명주기를 나타내는 대표적인 메소드들은 다음과 같습니다 ViewDidLoad ViewController 클래스가 생성될 때 딱 한번 실행됩니다. 보통 초기화 작업이 이루어집니다 ViewWillAppear 화면에 나타나기 직전에 실행됩니다 ViewDidload와 다르게 나타나기 직전마다 항상 실행됩니다 ViewDidAppear 화면에 나타난 직후에 실행됩니다. ViewWillDisAppear 화면에서 사라기지 직전에 실행됩니다 ViewDidDisAppear 화면에서 사라지고 난 직후에 실행됩니다</summary></entry><entry><title type="html">UICollectionViewDataSourcePrefetching</title><link href="https://sweetfood-dev.github.io/ios/2-UICollectionViewDataSourcePrefetching/" rel="alternate" type="text/html" title="UICollectionViewDataSourcePrefetching" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/2-UICollectionViewDataSourcePrefetching</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/2-UICollectionViewDataSourcePrefetching/">&lt;p&gt;UITableView/UICollectionView 에서 Pagenation을 위해 보통 아래 방법을 사용했다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        if indexPath.row == myItemList.count - 1 {
            fetchNextPage()
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
보여지는 Cell을 기준으로 List 의 마지막 아이템을 부르기 전에 다음 리스트 호출을 하는 식이다.&lt;br /&gt;
하지만 이번에 과제를 하면서 너무 버벅여 다른 방법을 찾아봤는데, UICollectionViewDataSourcePrefetching 프로토콜이 존재하였다&lt;br /&gt;
‘willDisplay’ 이 실제 보여지는 Cell을 기준으로 한다면 prefetchDataSource 는 이 작업을 백그라운드로 옮겨와 처리하는 것이다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension ViewController: UICollectionViewDataSourcePrefetching {
    func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {
		//내용 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 수정 후 눈에 띄게 속도가 향상되었다!!!&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">UITableView/UICollectionView 에서 Pagenation을 위해 보통 아래 방법을 사용했다.</summary></entry><entry><title type="html">CollectionViewLayout</title><link href="https://sweetfood-dev.github.io/ios/1-custom-layout/" rel="alternate" type="text/html" title="CollectionViewLayout" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/ios/1-custom-layout</id><content type="html" xml:base="https://sweetfood-dev.github.io/ios/1-custom-layout/">&lt;p&gt;일반적인 collectionview의 delegate와 datasource는&lt;br /&gt;
화면에 셀을 표시하는 역할을 담당합니다&lt;br /&gt;
표시 할 때 구성과 같은 layout은 UICollectionViewLayout을 구현하여 처리해야합니다&lt;br /&gt;
&lt;br /&gt;
커스텀 CollectionViewLayout의 &lt;strong&gt;주 역할&lt;/strong&gt;은 UICollectionView에서 요청하는 레이아웃 관련 정보를 제공하는 것입니다.&lt;br /&gt;
레이아웃을 미리 준비해 놓았다가 UICollectionView에서 요청하면 준비한 레이아웃 정보를 제공합니다.&lt;br /&gt;
이 때 몇가지 필수 메소드들이 존재합니다&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;prepare()&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;UICollectionView에 표시되는 전체 크기를 계산하고 각 셀의 레이아웃 속성, collectionView의 크기와 cell의 위치를 미리 계산(캐싱)하여 메모리에 적재한 뒤 유지합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;collectionViewContentSize&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;collectionView의 전체 높이와 너비를 반환합니다.&lt;/li&gt;
      &lt;li&gt;화면에 보이는 contents 뿐만 아니라 collectionView의 전체를 반환해야 합니다.&lt;/li&gt;
      &lt;li&gt;collectionView는 이 정보를 활용하여 내부적으로 scrollView의 크기를 구성합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;layoutAttributesForElements (in :)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;in의 범위 안에 있는 모든 셀들의 레이아웃 속성들을 배열에 담아 반환합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;**layoutAttributesForItem (at :) **
    &lt;ul&gt;
      &lt;li&gt;at으로 들어온 cell의 레이아웃 속성을 반환합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;호출 순서&lt;/strong&gt;&lt;br /&gt;
Layout prepare() : 전체 크기, 셀의 위치를 미리 계산&lt;br /&gt;
collectionView numberOfItemsInSection : 아이템의 전체 개수&lt;br /&gt;
Layout collectionViewContentSize : collectionView의 전체 크기(너비, 높이)&lt;br /&gt;
Layout layoutAttributesForElements : 범위 안에 있는 모든 셀들의 레이아웃 속성&lt;br /&gt;
Layout collectionViewContentSize :  collectionView의 전체 크기(너비, 높이)&lt;br /&gt;
collectionView cellForItemAt : cell 표시&lt;br /&gt;&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="iOS" /><summary type="html">일반적인 collectionview의 delegate와 datasource는 화면에 셀을 표시하는 역할을 담당합니다 표시 할 때 구성과 같은 layout은 UICollectionViewLayout을 구현하여 처리해야합니다 커스텀 CollectionViewLayout의 주 역할은 UICollectionView에서 요청하는 레이아웃 관련 정보를 제공하는 것입니다. 레이아웃을 미리 준비해 놓았다가 UICollectionView에서 요청하면 준비한 레이아웃 정보를 제공합니다. 이 때 몇가지 필수 메소드들이 존재합니다 prepare() UICollectionView에 표시되는 전체 크기를 계산하고 각 셀의 레이아웃 속성, collectionView의 크기와 cell의 위치를 미리 계산(캐싱)하여 메모리에 적재한 뒤 유지합니다. collectionViewContentSize collectionView의 전체 높이와 너비를 반환합니다. 화면에 보이는 contents 뿐만 아니라 collectionView의 전체를 반환해야 합니다. collectionView는 이 정보를 활용하여 내부적으로 scrollView의 크기를 구성합니다. layoutAttributesForElements (in :) in의 범위 안에 있는 모든 셀들의 레이아웃 속성들을 배열에 담아 반환합니다 **layoutAttributesForItem (at :) ** at으로 들어온 cell의 레이아웃 속성을 반환합니다.</summary></entry><entry><title type="html">클래스와 구조체</title><link href="https://sweetfood-dev.github.io/swift/Class-Struct-02/" rel="alternate" type="text/html" title="클래스와 구조체" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/Class-Struct-02</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/Class-Struct-02/">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Class&lt;/th&gt;
      &lt;th&gt;Struct&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;레퍼런스 타입&lt;/td&gt;
      &lt;td&gt;밸류 타입&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;객체화시 힙영역에 저장되고 그 주소값은 스택 영역에 저장, ARC로 메모리 관리&lt;/td&gt;
      &lt;td&gt;스택 영역에 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;상속가능&lt;/td&gt;
      &lt;td&gt;상속 불가, Protocol은 사용가능하다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;대입 연산 시 레퍼런스 공유&lt;/td&gt;
      &lt;td&gt;대입 연산 시  값 복사&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">Class Struct 레퍼런스 타입 밸류 타입 객체화시 힙영역에 저장되고 그 주소값은 스택 영역에 저장, ARC로 메모리 관리 스택 영역에 저장 상속가능 상속 불가, Protocol은 사용가능하다 대입 연산 시 레퍼런스 공유 대입 연산 시 값 복사</summary></entry><entry><title type="html">오토레이아웃의 우선순위</title><link href="https://sweetfood-dev.github.io/swift/4-autolayout-priority/" rel="alternate" type="text/html" title="오토레이아웃의 우선순위" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/4-autolayout-priority</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/4-autolayout-priority/">&lt;p&gt;&lt;strong&gt;constraint&lt;/strong&gt;의 priority&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;제약 사항간의 우선순위&lt;/li&gt;
  &lt;li&gt;뷰들의 크기가 유동적으로 변할 때, 제약들간에 충돌이 발생할 수 있다&lt;/li&gt;
  &lt;li&gt;이 때 우선순위를 결정함으로 충돌을 해결할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">constraint의 priority 제약 사항간의 우선순위 뷰들의 크기가 유동적으로 변할 때, 제약들간에 충돌이 발생할 수 있다 이 때 우선순위를 결정함으로 충돌을 해결할 수 있다.</summary></entry><entry><title type="html">ARC 및 참조 타입</title><link href="https://sweetfood-dev.github.io/swift/ARC/" rel="alternate" type="text/html" title="ARC 및 참조 타입" /><published>2021-02-04T00:00:00+09:00</published><updated>2021-02-04T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/ARC</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/ARC/">&lt;p&gt;&lt;strong&gt;ARC&lt;/strong&gt;
Swift에서 메모리를 자동으로 관리 &lt;br /&gt;
특정 객체가 참조되면 참조 카운트(Reference Count, RC)를 1증가 시키고, 모든 참조가 해제되어 0이 되면 메모리에서 해제시킨다.&lt;br /&gt;
컴파일 단계에서 실행되고 이 때문에 추가 자원 즉, 오버헤드가 있는 GC 대비 효율적이지만&lt;br /&gt;
참조 순환 즉, Memory Leak을 발생시킬 수 있다&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;순환 참조가 발생하는 경우&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;프로퍼티에서 인스턴스를 서로 강하게 참조&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class App {
    var os : iOS?
    
    deinit {
        print(&quot;app deinit&quot;)
    }
}

class iOS {
    var applications : App?
    
    deinit {
        print(&quot;ios deinit&quot;)
    }
}

var app : App? = App()
var ios : iOS? = iOS()

app?.os = ios
ios?.applications = app


app = nil
ios = nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드에서 각각 프로퍼티 &lt;strong&gt;os, applications&lt;/strong&gt;가 &lt;strong&gt;App, iOS&lt;/strong&gt; 인스턴스를 참조하여&lt;br /&gt;
App, iOS의 RC는 1씩 증가한 1인 상태이다&lt;br /&gt;
그 상태에서 참조 변수 app,ios가 nil로 변경되어 프로퍼티에 접근할 수 없어 순환참조가 발생하여 Memory Leak발생&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클로저에서 참조하는 경우&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class App {
    var os : iOS?
    let name : String
    
    init(name: String) {
        self.name = name
    }
    
    lazy var info: () -&amp;gt; String = {
        return self.name
    }
    deinit {
        print(&quot;app deinit&quot;)
    }
}

var app : App? = App(name: &quot;Wallet&quot;)
app = nil

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 경우처럼 info 안에서 self를 참조 하고 있을때, &lt;br /&gt;
참조변수 app을 nil로 변경되면 클로저와 인스턴스 사이 순환참조가 발생된다&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;순환 참조 방지 하는 방법&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;weak, unowend 사용
    &lt;ul&gt;
      &lt;li&gt;해당 키워드들로 인스턴스를 참조시 RC가 증가하지 않는다&lt;/li&gt;
      &lt;li&gt;weak은 아래서 설명하겠지만 옵셔널 타입으로 옵셔널 바인딩, 체이닝을 사용하여 런타임 크래시를 방지할 수 있다&lt;/li&gt;
      &lt;li&gt;unowend는 생명주기가 길거나 인스턴스가 존재함을 확신할 때 사용된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클로저에서 캡처리스트 작성
    &lt;ul&gt;
      &lt;li&gt;캡처리스트란 클로저가 참조하는 대상, 참조하는 방식을 지정하는 형식이다&lt;/li&gt;
      &lt;li&gt;즉, 강하게 캡처(참조)할지 약하게 캡처(참조)할지 지정이 가능하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;참조 방식&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;strong
    &lt;ul&gt;
      &lt;li&gt;객체를 &lt;strong&gt;소유&lt;/strong&gt;하여 RC를 증가시키는 프로퍼티&lt;/li&gt;
      &lt;li&gt;ARC로 인한 메모리 해제를 피하고 객체를 안전하게 사용할 때 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;weak
    &lt;ul&gt;
      &lt;li&gt;객체를 소유하지 않고 &lt;strong&gt;주소값&lt;/strong&gt;만을 가지고 있는 포인터 개념&lt;/li&gt;
      &lt;li&gt;메모리에서 해제될 경우 자동으로 &lt;strong&gt;nil&lt;/strong&gt;로 초기화되기 때문에 &lt;strong&gt;옵셔널 타입&lt;/strong&gt;으로 사용해야한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;unowend
    &lt;ul&gt;
      &lt;li&gt;weak과 비슷한 개념이지만 nil값이 될 수 없기 때문에 옵셔널 타입으로 선언하면 안된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;잘못된 설명이 있으면 지적 부탁드립니다.&lt;br /&gt;&lt;/p&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">ARC Swift에서 메모리를 자동으로 관리 특정 객체가 참조되면 참조 카운트(Reference Count, RC)를 1증가 시키고, 모든 참조가 해제되어 0이 되면 메모리에서 해제시킨다. 컴파일 단계에서 실행되고 이 때문에 추가 자원 즉, 오버헤드가 있는 GC 대비 효율적이지만 참조 순환 즉, Memory Leak을 발생시킬 수 있다</summary></entry><entry><title type="html">defer</title><link href="https://sweetfood-dev.github.io/swift/defer/" rel="alternate" type="text/html" title="defer" /><published>2021-02-04T00:00:00+09:00</published><updated>2021-02-04T00:00:00+09:00</updated><id>https://sweetfood-dev.github.io/swift/defer</id><content type="html" xml:base="https://sweetfood-dev.github.io/swift/defer/">&lt;p&gt;&lt;strong&gt;defer&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;작성된 위치와 순서에 상관없이 함수가 종료되기 직전에 호출된다&lt;/li&gt;
  &lt;li&gt;defer블록을 읽기전에 함수가 종료되면 defer블록은 실행되지 않는다.&lt;/li&gt;
  &lt;li&gt;defer 블록은 여러번 사용가능하다. defer문을 만나면 순차적으로 스택에 저장되고 스코프 종료 후 하나씩 pop해서 실행하기에 마지막 defer문 부터 역순으로 실행된다&lt;/li&gt;
  &lt;li&gt;defer 블록은 중첩으로도 사용 가능하다. 이때 순서는 바깥쪽 defer문으로부터 안쪽 defer문의 순서로 실행된다&lt;/li&gt;
&lt;/ol&gt;</content><author><name>권지수</name><email>kjsii123@naver.com</email></author><category term="Swift" /><summary type="html">defer 작성된 위치와 순서에 상관없이 함수가 종료되기 직전에 호출된다 defer블록을 읽기전에 함수가 종료되면 defer블록은 실행되지 않는다. defer 블록은 여러번 사용가능하다. defer문을 만나면 순차적으로 스택에 저장되고 스코프 종료 후 하나씩 pop해서 실행하기에 마지막 defer문 부터 역순으로 실행된다 defer 블록은 중첩으로도 사용 가능하다. 이때 순서는 바깥쪽 defer문으로부터 안쪽 defer문의 순서로 실행된다</summary></entry></feed>